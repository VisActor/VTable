# VTable Sheet 统一事件系统

## 🎯 设计目标

**合并两套事件系统为一套**，更简洁、更统一。

## ✅ 改进前后对比

### 改进前（两套系统）

```
tableInstance 触发事件
    ↓
WorkSheet 包装并触发 WorkSheetEventType 事件
    ↓
    ├─→ VTableSheet 的 EventManager 监听 WorkSheet 事件
    │   └─→ 处理内部逻辑（公式）
    │
    └─→ TableEventRelay 监听 tableInstance 事件
        └─→ 附带 sheetKey 传递给用户
```

**问题：**
- ❌ 两套事件系统（WorkSheet EventTarget + VTableSheet onTableEvent）
- ❌ 中间多了一层包装（WorkSheet.fire）
- ❌ 代码复杂，维护成本高

### 改进后（一套系统）✨

```
tableInstance 触发事件
    ↓
TableEventRelay 中转并附带 sheetKey
    ↓
    ├─→ EventManager 监听（内部业务逻辑）
    │   └─→ 处理公式相关逻辑
    │
    └─→ 用户监听（外部 API）
        └─→ 自定义业务逻辑
```

**优势：**
- ✅ 只有一套事件系统
- ✅ 统一的 API：`sheet.onTableEvent()`
- ✅ 减少中间层，性能更好
- ✅ 代码更简洁清晰

## 📝 核心改动

### 1. WorkSheet 类简化

```typescript
// 之前：继承 EventTarget
export class WorkSheet extends EventTarget implements IWorkSheetAPI {
  // ...
  this.fire(WorkSheetEventType.CELL_CLICK, event);  // 需要触发事件
}

// 现在：不再继承 EventTarget
export class WorkSheet implements IWorkSheetAPI {
  // ...
  // 不再需要 fire 事件，统一由 TableEventRelay 处理
}
```

**移除的代码：**
- ❌ `extends EventTarget`
- ❌ `super()` 调用
- ❌ 所有 `this.fire()` 调用
- ❌ `on()` 和 `fireEvent()` 方法

### 2. EventManager 改用统一 API

```typescript
// 之前：监听 WorkSheet 的事件
sheet.on(WorkSheetEventType.CELL_CLICK, this.eventManager.handleCellClickBind);
sheet.on(WorkSheetEventType.CELL_VALUE_CHANGED, this.eventManager.handleCellValueChangedBind);

// 现在：直接使用 VTableSheet 的 onTableEvent
this.sheet.onTableEvent('click_cell', (event) => {
  // 处理内部逻辑
});

this.sheet.onTableEvent('change_cell_value', (event) => {
  // 处理公式相关逻辑
});
```

### 3. VTableSheet 创建 WorkSheet 时简化

```typescript
// 之前
const sheet = new WorkSheet(this, options);
sheet.on(WorkSheetEventType.CELL_CLICK, this.eventManager.handleCellClickBind);
sheet.on(WorkSheetEventType.CELL_VALUE_CHANGED, this.eventManager.handleCellValueChangedBind);
sheet.on(WorkSheetEventType.SELECTION_CHANGED, this.eventManager.handleSelectionChangedForRangeModeBind);
sheet.on(WorkSheetEventType.SELECTION_END, this.eventManager.handleSelectionChangedForRangeModeBind);

// 现在
const sheet = new WorkSheet(this, options);
// EventManager 已经在初始化时通过 onTableEvent 注册了监听器
```

## 🔧 统一事件系统的使用

### 内部使用（EventManager）

```typescript
// EventManager.ts
private setupTableEventListeners(): void {
  // 监听单元格点击 - 用于更新公式栏
  this.sheet.onTableEvent('click_cell', (event) => {
    // event.sheetKey 自动附带
    if (this.sheet.formulaManager.formulaWorkingOnCell) {
      return;
    }
    this.sheet.formulaUIManager.updateFormulaBar();
  });

  // 监听单元格值改变 - 用于公式相关逻辑
  this.sheet.onTableEvent('change_cell_value', (event) => {
    this.sheet.formulaManager.formulaRangeSelector.handleCellValueChanged(event);
  });

  // 监听选择范围变化 - 用于公式范围选择
  this.sheet.onTableEvent('selected_changed', (event) => {
    this.sheet.formulaManager.formulaRangeSelector.handleSelectionChangedForRangeMode(event);
  });
}
```

### 外部使用（用户代码）

```typescript
// 用户代码
const sheet = new VTableSheet(container, options);

// 监听所有 sheet 的单元格点击
sheet.onTableEvent('click_cell', (event) => {
  console.log(`Sheet ${event.sheetKey} 点击了 [${event.row}, ${event.col}]`);
});

// 监听所有 sheet 的编辑
sheet.onTableEvent('change_cell_value', (event) => {
  console.log(`Sheet ${event.sheetKey} 编辑`);
  autoSave(event);
});
```

### 内部和外部监听共存

```typescript
// EventManager 内部监听（不会干扰用户）
this.sheet.onTableEvent('click_cell', (event) => {
  // 内部逻辑：更新公式栏
  this.sheet.formulaUIManager.updateFormulaBar();
});

// 用户监听（不会干扰内部）
sheet.onTableEvent('click_cell', (event) => {
  // 用户逻辑：显示提示
  console.log(`点击了 ${event.sheetKey}`);
});

// 两个监听器都会执行，互不干扰
```

## 📊 架构图

### 统一后的事件流

```
┌─────────────────────────────────────────┐
│         VTableSheet                     │
│                                         │
│  ┌──────────────────────────────────┐  │
│  │   TableEventRelay                │  │
│  │                                  │  │
│  │  • 存储所有事件监听器             │  │
│  │  • 为每个 WorkSheet 绑定包装函数 │  │
│  │  • 自动附带 sheetKey              │  │
│  └──────────────────────────────────┘  │
│                                         │
│  统一的事件 API：onTableEvent()         │
│         ↓                               │
│    ┌─────────┬─────────┐               │
│    │         │         │               │
│    ▼         ▼         ▼               │
│  内部      用户     其他                │
│  组件      代码     监听器              │
└─────────────────────────────────────────┘
```

### 事件传递流程

```
1. tableInstance.on('click_cell', wrappedCallback)
                    ↓
2. 用户点击单元格
                    ↓
3. tableInstance 触发 'click_cell' 事件
                    ↓
4. wrappedCallback 拦截，添加 sheetKey
                    ↓
5. 调用所有注册的监听器
   ├─→ EventManager 的监听器（内部逻辑）
   ├─→ 用户的监听器 A
   ├─→ 用户的监听器 B
   └─→ ...
```

## ✨ 核心优势

### 1. 简洁性

```typescript
// 只有一个 API
sheet.onTableEvent(type, callback);
sheet.offTableEvent(type, callback);
```

### 2. 统一性

```typescript
// 内部和外部使用相同的 API
// 内部
this.sheet.onTableEvent('click_cell', handler);

// 外部
sheet.onTableEvent('click_cell', handler);
```

### 3. 灵活性

```typescript
// 可以监听任何 VTable 事件
sheet.onTableEvent('click_cell', handler);
sheet.onTableEvent('scroll', handler);
sheet.onTableEvent('after_render', handler);
sheet.onTableEvent('任何VTable事件', handler);
```

### 4. 性能

```typescript
// 减少了中间层
// 之前：tableInstance → WorkSheet.fire → EventManager
// 现在：tableInstance → EventManager（直接）
```

### 5. 可维护性

```typescript
// 只需要维护一套事件系统
// 代码更清晰，逻辑更简单
```

## 🎯 总结

### 核心改进

1. ✅ **移除 WorkSheet 的 EventTarget** - 不再需要中间层
2. ✅ **统一使用 onTableEvent** - 内部和外部都用同一个 API
3. ✅ **简化事件流** - tableInstance → TableEventRelay → 所有监听器
4. ✅ **自动附带 sheetKey** - 内部和外部都能知道是哪个 sheet

### 代码改动

| 文件 | 改动 |
|------|------|
| `WorkSheet.ts` | 移除 EventTarget 继承和所有 fire 调用 |
| `EventManager.ts` | 改用 onTableEvent 监听事件 |
| `VTableSheet.ts` | 移除 sheet.on 的事件注册代码 |

### 最终效果

```typescript
// 统一的 API，简洁强大
const sheet = new VTableSheet(container, options);

// 用户监听
sheet.onTableEvent('click_cell', (event) => {
  // event.sheetKey 自动附带
  console.log(`Sheet ${event.sheetKey} 被点击`);
});

// 内部组件也用同样的方式监听
// 互不干扰，完美共存
```

---

**结论：** 统一后的事件系统更简洁、更统一、更易维护！🎉


