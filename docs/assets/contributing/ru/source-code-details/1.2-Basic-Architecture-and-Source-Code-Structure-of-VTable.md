---
title: 1.2 Базовая Архитектура и Структура Исходного Кода VTable

key words: VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Визуализация,Диаграмма,Данные,Таблица,График,ГИС,LLM
---
### Основная Архитектура VTable


#### Структурный Анализ


VTable можно грубо разделить на несколько модулей: слой обработки данных, модуль макета, модуль рендеринга, модуль событий, модуль взаимодействия, управление состоянием, коммуникация компонентов.

* Слой обработки данных отвечает за управление исходными данными, обработку операций, таких как транспозиция строк-столбцов и встроенная сортировка, а затем передачу обработанных данных обратно для рендеринга таблицы;

* Модуль макета в основном отвечает за базовый макет заголовка, макет заголовка сводной таблицы, макет ячеек и алгоритм расчета высоты строк и столбцов, а затем передает рассчитанный макет слою рендеринга для отрисовки.

* Модуль рендеринга в основном вызывает `vrender` для рендеринга диаграмм и различных графических элементов и полагается на модуль макета.

*  Модуль взаимодействия обрабатывает различные пользовательские операции кликов, такие как клик по заголовку для сортировки, редактирование ячеек и т.д.;

*  Модуль событий обрабатывает внутренние пользовательские события, включая события жизненного цикла, корректировки ширины столбцов и высоты строк, прокрутку таблицы и т.д.;

* Модуль состояния обрабатывает хранение состояний, таких как навести, выбрать, menu, sort и т.д.;

Different modules implement publish-subscribe through `EventTarget`.

#### Data Processing Layer


This layer mainly receives incoming data и stores it, while performing basic transformations на the data, including aggregation и sorting operations.

During the initialization из `ListTable`, некоторые basic operations are performed на the incoming data. первый, `options.records` или `options.dataSource` is passed к `CachedDataSource` для instantiation, и then the instance is placed в `table.internalProps.dataSource` для internal use по the component, such as when performing layout calculations для the table.

Initialization из the data layer:

* первый step: When initializing ListTable, handle dataSource или records

* Step two: Use different judgments к put dataSource или records into internalProps, so that subsequent data changes can directly operate на the dataSource объект\r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/AO2NwkOfkhJR3IbEIUmcoEvYnjg.gif' alt='' ширина='820' высота='auto'>

*  VTable\packages\VTable\src\ListTable.ts

```xml
constructor(container?: HTMLElement | ListTableConstructorOptions, options?: ListTableConstructorOptions) {
    //...
    if (options.dataSource) {
      _setDataSource(this, options.dataSource);
    } else if (options.records) {
      this.setRecords(options.records as любой, { sortState: internalProps.sortState });
    } else {
      this.setRecords([]);
    }
    //...
}

```
* `setDataSource` и `setRecords` methods: VTable\packages\VTable\src\core\tableHelper.ts

```xml
// addReleaseObj 方法可以粗略概括为调用回调函数去更新组件内部的数据
export функция _setDataSource(table: BaseTableAPI, dataSource: DataSource): void {
  _dealWithUpdateDataSource(table, () => {
    if (dataSource) {
      if (dataSource instanceof DataSource) {
        table.internalProps.dataSource = dataSource;
      } else {
        // 如果是初次调用该方法，会将 dataSource 初始化为 CachedDataSource 的实例，后续如果更新就不会重复 новый
        const newDataSource = (table.internalProps.dataSource = новый CachedDataSource(dataSource));
        table.addReleaseObj(newDataSource);
      }
    } else {
      table.internalProps.dataSource = DataSource.EMPTY;
    }
    table.internalProps.records = null;
  });
}

export функция _setRecords(table: ListTableAPI, records: любой[] = []): void {
  _dealWithUpdateDataSource(table, () => {
    table.internalProps.records = records;
    // 这里通过调用 CachedDataSource.ofArray 方法将records转换为实例所需的dataSource结构
    const newDataSource = (table.internalProps.dataSource = CachedDataSource.ofArray(
      records,
      table.internalProps.dataConfig,
      table.pagination,
      table.internalProps.columns,
      table.internalProps.layoutMap.rowHierarchyType,
      getHierarchyExpandLevel(table)
    ));
    // 可以看到这里调用 addReleaseObj 方法将 CachedDataSource 处理过的records 存放进 table.internalProps.dataSource 中
    table.addReleaseObj(newDataSource);
  });
}

```
<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">  The CachedDataSource.ofArray method internally also uses новый CachedDataSource к adapt the records.
</div>
*  VTable/packages/src/data/CachedDataSource.ts

в this class, caching operations are implemented для the DataSource. It also inherits от `DataSource`.

```javascript
export class CachedDataSource extends DataSource {
  // ...
  static ofArray(
    массив: любой[],
    dataConfig?: IListTableDataConfig,
    pagination?: IPagination,
    columns?: ColumnsDefine,
    rowHierarchyType?: 'grid' | 'tree',
    hierarchyExpandLevel?: число
  ): CachedDataSource {
    возврат новый CachedDataSource(
      {
        get: (index: число): любой => {
          возврат массив[index];
        },
        length: массив.length,
        records: массив
      },
      dataConfig,
      pagination,
      columns,
      rowHierarchyType,
      hierarchyExpandLevel
    );
  }
  //...
}

```
*   VTable/src/data/DataSource.ts

в the `DataSource` class, Вы можете see that the management operations для `records` are implemented в DataSource, и the processing из raw data is abstracted into this module.

```javascript
 export интерфейс DataSourceParam {
  get?: (index: число) => любой; // 这里是对数据的代理
  length?: число;
  */** 需要异步加载的情况 请不要设置records 请提供get接口 */*
  records?: любой;
  // records 的增删操作
  added?: (index: число, count: число) => любой;
  deleted?: (index: число[]) => любой;
  canChangeOrder?: (sourceIndex: число, targetIndex: число) => логический;
  changeOrder?: (sourceIndex: число, targetIndex: число) => void;
}

export class DataSource extends EventTarget implements DataSourceAPI {
 constructor(
    dataSourceObj?: DataSourceParam,
    dataConfig?: IListTableDataConfig,
    pagination?: IPagination,
    columns?: ColumnsDefine,
    rowHierarchyType?: 'grid' | 'tree',
    hierarchyExpandLevel?: число
  ) {
    super();
    // ...
    this.dataSourceObj = dataSourceObj;
    this.dataConfig = dataConfig;
    this._get = dataSourceObj?.get;
    this.columns = columns;
    this._source = dataSourceObj?.records ? this.processRecords(dataSourceObj?.records) : dataSourceObj;
    }
}

```
The logic layer mainly involves various types из logic processing, such as chart transposition, data sorting, filtering logic, и aggregation. The main data processing logic is stored в these files, including APIs exposed для external calls. The data initialization mentioned earlier is done по calling the methods в these files:

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">VTable\packages\VTable\src\data\CachedDataSource.ts
VTable\packages\VTable\src\data\DataSource.ts
VTable\packages\VTable\src\dataset\dataset.ts
VTable\packages\VTable\src\dataset\dataset-pivot-table.ts
</div>
для example, the core logic из Следующий two APIs:

<div style="display: flex;"><div style="flex: 47; отступ:5px;"><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DOdsb0Qw3oGSpzxETiNcspR2n5f.gif' alt='' ширина='500' высота='auto'>

</div><div style="flex: 52; отступ:5px;"><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/OgycbIbePoB6DnxGstzcliagnic.gif' alt='' ширина='503' высота='auto'>

</div></div>
*  VTable\packages\VTable\src\data\DataSource.ts

```javascript
// 树形结构的展开和收起
toggleHierarchyState(index: число, bodyStartIndex: число, bodyEndIndex: число) {
    //... 
 }
 
*/***
** 修改多条数据recordIndexs*
**/*
updateRecords(records: любой[], recordIndexs: (число | число[])[]) {
  //...
}
//...

```
#### Layout Module

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">The core files из the layout module are located в VTable\packages\VTable\src\layout
</div>
The Layout module is the core module из the VTable component, including the header из the basic table, the header из the pivot table, the layout из chart cells, the logic из tree headers и tree cells. After adjustments are completed through the layout module, it is then handed over к the rendering layer для rendering. в addition, this file also contains a lot из auxiliary logic для layout adjustments.

#### Rendering Module


VTable 的核心渲染能力是通过 [VRender](https://github.com/VisActor/VRender) 实现的，其内部借用了 `VRender`的能力去实现表格的初始化渲染、数据更新与删除后的重新渲染、用户拖拽后的重新渲染等等。

Inside the VTable, a scenegraph is maintained, which defines the core rendering logic within the VTable.

The initialization из the scene tree и the definition из the `render` method are located в `BaseTable`:

*  VTable/packages/VTable/src/core/BaseTable.ts

```javascript
export abstract class BaseTable extends EventTarget implements BaseTableAPI {
  //....
  constructor(container: HTMLElement, options: BaseTableConstructorOptions = {}) {
  //...
      this.scenegraph = новый Scenegraph(this);
   //...
  }
  
  */***
*   * 重绘表格(同步绘制)*
*   */*
  render(): void {
    this.scenegraph.renderSceneGraph();
  }
 }

```
*  VTable/packages/VTable/src/scenegrpah/scenegrapg.ts

```javascript
*/***
* * @description: 表格场景树，存储和管理表格全部的场景图元*
* * @возврат {*}*
* */*
export class Scenegraph {
  //...
  stage: IStage;
  //...
   
  */***
*   * @description: 绘制场景树*
*   * @param {любой} element*
*   * @param {CellRange} visibleCoord*
*   * @возврат {*}*
*   */*
  renderSceneGraph() {
    this.stage.render();
  }

```
The entry point для the initial rendering is the BaseTable.render method, which internally calls renderSceneGraph в the scenegraph. It then uses the render method на the Stage created по createStage в VRender к draw the table к the specified DOM node. в this point, the первый step из rendering is complete, и the subsequent rendering layer logic is invoked through the scenegraph.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ATKxwhs4khU0WobZpwxcDh7pnmc.gif' alt='' ширина='1000' высота='auto'>

#### Interaction Module


The interaction module mainly handles two tasks:

*  Listen к table custom events

* Change table-related status, re-render the table

The interaction module mainly consists из the event module и state management, completing operations such as навести highlighting, выбрать highlighting, и table scrolling.

#### Event Module


*  VTable\packages\VTable\src\event\event.ts

event.ts exposes `EventManager`, `EventManager` is used к manage various events из the table, including mouse events (such as нажать, double-нажать к auto-adjust column ширина, mouse movement, etc.) и keyboard events (such as mouse прокрутка, enter key к submit edited content, etc.).

VTable internally listens к most custom events within the table, including wheel и нажать events, through `Stage.addEventListener` provided по VRender. для example, the wheel event is used к implement table scrolling; нажать is used к change the selectState и simultaneously trigger the externally passed click_cell обратный вызов.

#### State Management


**Global State Management**: The state here exists independently из the table, и when the state changes, it will redraw the table. `StateManager` mainly includes Следующий parts:

* hoverState table навести configuration и the currently hovered cell

*  selectState table currently selected cell

* frozen rows или columns

*  прокрутка The текущий table's horizontal и vertical прокрутка позиция

* Highlight state из sparkLine mini chart

* Custom sorting within sort


These data are defined в `StateManager` и generated during table initialization. по updating the State, the table can be redrawn. The core file из `StateManager` is defined в: `VTable\packages\VTable\src\state\state.ts`

#### Component Communication


The component communication part из VTable relies на the `EventTarget` class. по observing the source code structure, it can be found that most modules inherit от `EventTarget` и implement event communication through `EventTarget`.

*   VTable/src/data/Datasource.ts

```javascript
export class DataSource extends EventTarget implements DataSourceAPI { //...

```
*   VTable/src/core/BaseTable.ts

```javascript
export abstract class BaseTable extends EventTarget implements BaseTableAPI { //...

```
*   VTable/src/header-helper/style/Style.ts

```javascript
export class Style extends EventTarget implements ColumnStyle {

```
`EventTarget` internal structure:

*  VTable/src/event/EventTarget.ts

```javascript
import тип {
  TableEventListener,
  EventListenerId,
  TableEventHandlersEventArgumentMap,
  TableEventHandlersReturnMap
} от '../ts-types';
import { isValid } от '@visactor/vutils';

let idCount = 1;

export class EventTarget {
  private listenersData: {
    listeners: { [тип в keyof TableEventHandlersEventArgumentMap]?: TableEventListener<тип>[] };
    listenerData: {
      [id: число]: {
        тип: строка;
        listener: TableEventListener<keyof TableEventHandlersEventArgumentMap>;
        remove: () => void;
      };
    };
  } = {
    listeners: {},
    listenerData: {}
  };

  */***
*   * 监听事件*
*   * @param тип 事件类型*
*   * @param listener 事件监听器*
*   * @returns 事件监听器id*
*   */*
  на<тип extends keyof TableEventHandlersEventArgumentMap>(                        
    тип: тип,
    listener: TableEventListener<тип>
  ): EventListenerId {
    ...
  }

  off(тип: строка, listener: TableEventListener<keyof TableEventHandlersEventArgumentMap>): void;
  off(id: EventListenerId): void;
  off(
    idOrType: EventListenerId | строка,
    listener?: TableEventListener<keyof TableEventHandlersEventArgumentMap>
  ): void {
     // ...
  }
    
   // 添加事件监听
  addEventListener<тип extends keyof TableEventHandlersEventArgumentMap>(
    тип: тип,
    listener: TableEventListener<тип>,
    option?: любой
  ): void {
    this.на(тип, listener);
  }
    
  // 移除事件监听
  removeEventListener(тип: строка, listener: TableEventListener<keyof TableEventHandlersEventArgumentMap>): void {
      // ...
  }

  hasListeners(тип: строка): логический {
      // ...
  }
  
  // 触发事件
  fireListeners<тип extends keyof TableEventHandlersEventArgumentMap>(
    тип: тип,
    event: TableEventHandlersEventArgumentMap[тип]
  ): TableEventHandlersReturnMap[тип][] {
      // ...
  }
  
  // 释放事件监听
  release(): void {
    delete this.listenersData;
  }
}


```
* Internal component communication:

* Communication between different layers is carried out through events, функция calls, или data sharing. для example, when the interaction module receives a user's sorting operation request, it will call the sorting функция из the logic processing layer и pass the sorting result к the rendering layer для re-rendering.

* The rendering layer may update based на the data от the data layer, triggering certain operations в the interaction module, such as updating the display из the selected state, etc.

* External обратный вызов:

* External incoming event subscriptions are called back through `fireListeners`, для example, different lifecycle events will be promptly called back к the user through `fireListeners`.

#### Overall Module Design


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/EvQ6bQHFhoosf0x7SkBc8PDbnwd.gif' alt='' ширина='1000' высота='auto'>



### VTable Source Code Structure


#### VTable Module Overview


* Data Processing Layer

`Options` The table configuration passed в по the user, used к describe the structure, content, и style из the table.

`DataSource` is responsible для managing data, defining methods для reading и manipulating data;

`Dataset` Pivot table data parsing module;

* Layout Module

`Layout` is responsible для the layout calculation из basic tables и pivot table headers, as well as the calculation из cell row и column heights, etc.;

*  Rendering Module

`Scenegraph` module is responsible для the creation и updating из table scene nodes;

`SceneProxy` is a submodule из Scenegraph, responsible для calculating the maximum число из display rows и columns, initializing the scene tree logic, и the logic для progressive table rendering.

`Theme` manages the global styles из the module table, providing styles для the cells; 

* State Management

`StateManager` is responsible для managing the текущий state из the table, including frozen, selected, навести, прокрутка, и other table states.

*  Event Module

`EventManager` is responsible для managing the definition и listening из custom events.

* Component Communication

`EventTarget` provides a publish-subscribe pattern, responsible для event communication between different modules;

#### VTable Directory Structure


по observing the directory under the `src` folder, Вы можете see the general project structure, which is strictly divided according к modules. Basically, каждый file exports a Class, и по constructing instances в different times и places, the initialization из the VTable is completed.

The diagram below roughly shows the code structure из VTable и the functions из каждый file.

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VFfewdljLhX2CabukvQc9aRonGg.gif)

#### Path Analysis


Starting от `src/index.ts`, Вы можете see that VTable exposes the two most commonly used components, ListTable и PivotTable, от here. This is where different components из VTable converge.

*  VTable/packages/VTable/src/index.ts

```javascript
import { graphicUtil, registerForVrender } от '@src/vrender';
registerForVrender();
// ...
import { ListTableAll as ListTable } от './ListTable-все';
import { PivotTableAll as PivotTable } от './PivotTable-все';
//...
export {
  //...,
  ListTable,
  //...
  PivotTable,
  PivotChart,
};
//...

```
Enter `ListTable-все`, Вы можете see that the necessary components are registered during the initialization из `ListTable` so that the chart instance can be called в different places.

*  VTable\packages\VTable\src\ListTable-все.ts

```javascript
import { ListTable } от './ListTable';
// ...

registerAxis(); // 注册坐标轴
registerEmptyTip(); // 注册 EmptyTip 组件
// ...
registerVideoCell();
export class ListTableAll extends ListTable {}

```
*  VTable/packages/VTable/src/ListTable.ts

```javascript
export class ListTable extends BaseTable implements ListTableAPI {

```
в BaseTable, the most core modules are defined.

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">Scenegraph  Scene Tree
StateManager  State Management
EventManager Interaction Event Management
</div>
*  VTable/packages/VTable/src/core/BaseTable.ts

```javascript
export abstract class BaseTable extends EventTarget implements BaseTableAPI {
  constructor {
      ...
      this.scenegraph = новый Scenegraph(this);
      this.stateManager = новый StateManager(this);
      this.eventManager = новый EventManager(this);   
      this.animationManager = новый TableAnimationManager(this);
      ...
  }     
}

```
BaseTable inherits от the EventTarget class к implement publish-subscribe operations.

* After performing path analysis на VTable, we can draw a rough reference diagram из the ListTable modules:

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/XLzHwVyQMhwn0ybjI9DcFIZRn4e.gif)

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">PivotTable also adopts a similar architecture, inheriting от BaseTable just like `ListTable`.</div>
</div>
### Conclusion


VTable, through reasonable modular management из various functions, can maximize development efficiency и reduce the learning curve.

This article divides the structure из VTable into layers, categorizing it into data layer, logic layer, rendering layer, и interaction module. по analyzing different layers, it introduces the basic architecture из VTable.

Then, starting от the directory, it introduces the source code structure из VTable, the division из various modules, и the functions responsible для different modules. After analyzing от two perspectives, one can have a certain understanding из the overall architecture из VTable. \r

# This document is provided по Следующий personnel


taiiiyang( https://github.com/taiiiyang) 


