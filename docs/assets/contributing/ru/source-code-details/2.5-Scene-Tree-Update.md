---
заголовок: 2.5 Scene Tree Update    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## **Trigger Update**

Under what circumstances does the scene tree update occur? Generally, it is triggered в three situations: данные change-driven, user interaction, и макет change.

*  **данные-driven**: When the attributes из the таблица change, such as ширина, высота, или element changes: trigger `updateColширина` / `updateRowвысота` / `updateCell` respectively.    

*  **User Interaction**: Users interact с the таблица: trigger `изменение размера` (перетаскивание column ширина) / `updateсортировкаиконка` (сортировка иконка)    

*  **макет Change**: Changes в device размер и display mode trigger changes в макет, which will also lead к таблица updates: `dealширинаMode` (adaptive макет)    

## Update Process


##### **1. Attribute Modification (Core Method: **`**setAttribute**`**,)**​**

Directly modify element attributes (such as позиция, размер, style)    

*  **Column ширина Update**: Modify the `ширина` attribute из the column container using `setAttribute`.    

```xml
updateColширина(col: число, deltaX: число) {
  const columnGroup = this.getColGroup(col);
  columnGroup.setAttribute('ширина', newширина); *// 直接修改列宽（触发脏标记）*
  this.updateContainer(true);                  *// 触发布局更新*
}    

```
*  **Line высота Update**: Adjust the \u0060высота\u0060 attribute из the line container к synchronously update the vertical макет.    \r

```xml
updateRowвысота(row: число, deltaY: число) {
  const rowGroup = this.getRowGroup(row);
  rowGroup.setAttribute('высота', newвысота); *// 修改行高*
  this._updateContainerвысота(row, deltaY);    *// 联动容器高度*    

```
---
##### **2. макет Recalculation (Core методы: **`**updateContainer**`**/**`**dealширинаMode**`**)​**

Recalculate container coordinates и dimensions based на attribute changes, specifically controlling the update process through the `needUpdateContainer` flag. This ensures that макет calculations (column ширина/coordinate adjustments), размер synchronization (таблица/frozen area), компонент status (прокрутка bar), и other steps are executed sequentially only when updates are needed, followed по rendering submission (`updateNextFrame`). The rendering engine is triggered (rendering the следующий frame) through `stвозраст.renderNextFrame`.

```xml
  updateContainer(async: логический = false) {
    if (async) {
      if (!this._needUpdateContainer) {
        this._needUpdateContainer = true;
        setTimeout(() => {
          this.updateContainerSync();
        }, 0);
      }
    } else {
      this._needUpdateContainer = true;
      this.updateContainerSync();
    }
  }

 updateContainerSync() {
    if (!this._needUpdateContainer) {
      возврат;
    }
    this._needUpdateContainer = false;
    this.updateContainerAttrширинаAndX();
    this.updateтаблицаSize();
    this.компонент.updateScrollBar();

    this.updateDomContainer();

    this.updateNextFrame();
  }
    

```
**Adaptive макет**: Dynamically allocate remaining space, overriding manual adjustment results. My interpretation focuses на `dealвысотаMode` и `dealwitdhMode`:    

`dealширинаMode()` method is responsible для handling the adaptive макет и авто-fill logic из таблица column ширинаs: When `ширинаMode: 'adaptive'` is включен, it первый clears the historical column ширина cache, calculates the fixed total ширина из the row header и the право frozen columns, и proportionally allocates the remaining canvas space к non-frozen columns. If `автоFillширина` is включен, it checks whether the total content ширина is less than the canvas ширина, и if insufficient, it proportionally enlarges the non-frozen columns. After completing the column ширина calculation, it traverses the sub-column elements из the body area (`bodyGroup`), column header area (`colHeaderGroup`), row header area (`rowHeaderGroup`), и corner header area (`cornerHeaderGroup`), accumulates the actual ширина из каждый column, и dynamically sets the total ширина из the container. Finally, it adjusts the coordinate positions из the column header и the body к ensure that the column header is closely aligned к the право из the corner header и the body area is closely aligned к the право из the row header, forming a complete horizontal макет flow. Ultimately, the container property update drives the rendering engine к synchronize the visual Производительность.

`dealвысотаMode` The logic для handling высота и ширина is highly similar и symmetrical. Both conform к the core idea из таблица adaptive макет;    

---
##### **3. Dirty Marking (VRender Internal Mechanism)**

Mark the primitives that need к be redrawn к avoid full rendering. Dirty marking is a **Производительность optimization technique** used к identify данные или objects that need updating, avoiding full computation или rendering, thereby improving efficiency. в graphics rendering, it tracks the changed parts и only processes the "dirty" areas instead из the entire scene.    \r

---
##### **4. Asynchronous Rendering Submission (Core Method: **`**renderNextFrame**`**)​**

*  **Unified submission entry**: все updates ultimately call `stвозраст.renderNextFrame()`.    

```xml
updateNextFrame() {
  this.stвозраст.renderNextFrame();
}    

```


# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)