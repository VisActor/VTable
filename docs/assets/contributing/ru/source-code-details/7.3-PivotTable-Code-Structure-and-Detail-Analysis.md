---
заголовок: 7.3 сводныйтаблица код Structure и Detail Analysis    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
# Tree Display


## Requirements


A major feature из сводныйтаблица is the tree-like `rowHeader` и `columnHeader`. Users can define the display format из the tree based на Следующий configuration:    

*  `rowHierarchyType / columnHierarchyType` : Tree display mode    

*  grid (supports row и column)        

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/FQABbDAB0o2vtKxp4Qjcc9DZnBf.gif' alt='' ширина='430' высота='авто'>

*  tree (only supports row)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Q1NsbNwRio0uEMxhFxYcu0mMnpe.gif' alt='' ширина='252' высота='авто'>

*  grid-tree (supports row и column)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KiLTbkFzhoefrIxsbV3cI3hWngf.gif' alt='' ширина='516' высота='авто'>

*  `indicatorsAsCol`: Whether indicators are displayed as список headers, по умолчанию is true    

* `rowExpandLevel / columnExpandLevel`: по умолчанию развернуть level    

* When пользовательскийizing `rowTree / columnTree`, Вы можете use `node.hierarchyState` к set the свернуть state из каждый node    



## Problem


от the above requirements, we might have некоторые questions❓:    \r

1. How к render a tree-like `rowHeader / columnHeader`, и what **данные** is needed?    

1. Different `rowHierarchyType / columnHierarchyType` will have different **merged cells и expansion logic**, how к handle it more elegantly?    

1. How does the **макет algorithm** handle these types из `HierarchyType`    



## Source код

в section 7.2 "автоmatic Organization из Dimension Tree", we learned that в the `setRecords` method из the `данныеset` module, the dimension members `rowKeys` collected от the raw данные are used к **call** `**ArrToTree**` **к assemble the dimension tree, stored в** `**данныеset.rowHeaderTree**`**.**

Subsequent сводныйтаблица will continue к process based на `rowHeaderTree`, rendering the tree header. Let's take a loхорошо в the details из this entire process.    



### данныеset.rowHeaderTree / colHeaderTree

* If the user passes a пользовательский tree `пользовательскийRowTree/colHeaderTree`, it is directly assigned к `данныеset.rowHeaderTree / colHeaderTree`    

* Otherwise, use `ArrToTree` и `ArrToTree1` к convert dimension members `rowKeys` и `colKeys` into a tree structure, и then assign values.    

```xml
// packвозрастs/vтаблица/src/данныеset/данныеset.ts
export class данныеset {
    ...
    
    setRecords(records: любой[] | Record<строка, любой[]>) {
        ...
        
        if (this.пользовательскийRowTree) {
            this.rowHeaderTree = this.пользовательскийRowTree;
        } else {
            if (this.rowHierarchyType === 'tree') {
                this.rowHeaderTree = this.ArrToTree1(...)
            } else {
                this.rowHeaderTree = this.ArrToTree(...)
            }
        }
        
        if (this.пользовательскийColTree) {
            this.colHeaderTree = this.пользовательскийColTree;
        } else {
            this.colHeaderTree = this.ArrToTree(...)
        }
    }
}    

```


### DimensionTree

* It will be passed от `данныеset.rowHeaderTree / colHeaderTree` или user `пользовательский header tree` as a параметр к the `DimensionTree` class, instantiated к generate `rowDimensionTree / columnDimensionTree`

```xml
// packвозрастs/vтаблица/src/сводныйтаблица.ts
export class сводныйтаблица extends Baseтаблица implements сводныйтаблицаапи {
    constructor(...) {
        ...
        
        const keysResults = parseColKeyRowKeyForсводныйтаблица(this, options);
        let { columnDimensionTree, rowDimensionTree } = keysResults;
        
        ...
        
        if (!options.columnTree) {
            
            **columnDimensionTree = новый DimensionTree(**
                (this.данныеset.colHeaderTree as ITreeмакетHeadNode[]) ?? [],
                ...
            );
        }
        
        if (!options.rowTree) {
            
            **rowDimensionTree = новый DimensionTree(**
                (this.данныеset.rowHeaderTree as ITreeмакетHeadNode[]) ?? [],
                ...
            )
            
        }
        
        
    }    
}    

```


* в the `constructor` функция из the `DimensionTree` class, the core logic is в `this.setTreeNode(this.tree, 0, this.tree)`. `setTreeNode` is a recursive функция that will **traverse the tree** и process каждый node с `setTreeNode`.

*  Generate node `id`    

*  **According к **`**hierarchyType**`** configuration и **`**node.hierarchyState**`**, update the **`**level**`** attribute из the node** (к be used для макет later), update the **`DimensionTree`**'s **`totalLevel`** и **`размер`** attributes    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/HV3nbhEezo70flxd4sHcKPVtnqh.gif' alt='' ширина='1000' высота='авто'>



### сводныйHeaderмакетMap

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">**макетMap is one из the core parameters из сводныйтаблица,** which will directly determine the макет, ширина, и высота из the cells.    
</div>
```Typescript
// packвозрастs/vтаблица/src/сводныйтаблица.ts
export class сводныйтаблица extends Baseтаблица implements сводныйтаблицаапи {
    constructor(...) {
        ...
        
        **this.internalProps.макетMap = новый сводныйHeaderмакетMap**(
            this,
            this.данныеset,
            columnDimensionTree,
            rowDimensionTree
        );
    }    
}    

```


Let's see what the `сводныйHeaderмакетMap` class does:    

1. **Determine the logic для merged cells и node свернуть state**. Следующий four attributes will determine the display content и merged cell logic из `cornerHear`, `columnHear`, `rowHeader`    

```Typescript
// packвозрастs/vтаблица/src/макет/сводный-header-макет.ts
export class сводныйHeaderмакетMap implements макетMapапи {
    /**下面四份代表实际展示的 如果隐藏了某部分表头 那这里就会相比上面的数组少了隐藏掉的id 例如收hideIndicatorимя影响*/
    _cornerHeaderCellIds: число[][] = [];
    private _columnHeaderCellIds: число[][] = [];
    private _rowHeaderCellIds: число[][] = [];
    private _rowHeaderCellIds_FULL: число[][] = []; //分页需求新增  为了保存全量的id  当页的是_rowHeaderCellIds
    
    // 记录单元格 Headerданные 对象
    cornerHeaderObjs: Headerданные[];
    columnHeaderObjs: Headerданные[] = [];
    rowHeaderObjs: Headerданные[] = [];
    ...  
}    

```
* When `rowHierarchyType` is `grid`, the two-dimensional массив `_rowHeaderCellIds` specifies the unique Id corresponding к каждый cell. If the Ids are the same, it indicates a merged cell situation. As shown в the лево imвозраст below, Id:23 is a merged situation, и Id:27 is a non-merged situation. \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YGiqbH16soUzrexxVECcdcgrn6c.gif' alt='' ширина='1000' высота='авто'>

* When `rowHierarchyType` is `tree`, все dimensions will be displayed в the same column, `_rowHeaderCellIds` will be as shown в the figure below: \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/P8hzbi3dYoUKJ2xC41GcYuEenxe.gif' alt='' ширина='842' высота='авто'>

*  и `node.hierarchyState` will record the node's collapsed state    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KqblbdKpPopXLSxjxQvc11VTn3c.gif' alt='' ширина='870' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ItXHbqqswodGP9xCpJMcWINTnSg.gif' alt='' ширина='710' высота='авто'>



2. The specific logic для generating row header и column header cell данные can be seen в `this._addHeaders()`, `this._addHeadersForGridTreeMode()`, и `this._addHeadersForTreeMode()`.

```Typescript
// packвозрастs/vтаблица/src/макет/сводный-header-макет.ts
export class сводныйHeaderмакетMap implements макетMapапи {
    ...
    
    constructor(...) {
        
        // 生成列表头单元格
        this._generateColHeaderIds();
        // 生成行表头单元格
        this._generateRowHeaderIds();
    }
    
    _generateRowHeaderIds() {
        if (this.rowDimensionTree.tree.children?.length >= 1) {
            if (this.rowHierarchyType === 'tree') {
                **this._addHeadersForTreeMode(...)**
            } else if (this.rowHierarchyType === 'grid-tree') {
                const startRow = 0;
                **this._addHeadersForGridTreeMode(...)**
            } else {
                **this._addHeaders(...)**
            }
    }
}    

```
* The logic из the three `this._addHeadersXX()` методы is similar, и they will combine с the `dealHeaderXX()` method к form recursive logic, **traverse the tree, generate** `**Headerданные**` **тип cell данные**, и perform appropriate storвозраст.\r



3. Generate `cornerHeadr` cell данные; set column ширина    

```Typescript
// packвозрастs/vтаблица/src/макет/сводный-header-макет.ts
export class сводныйHeaderмакетMap implements макетMapапи {
    ...
    
    constructor(...) {
        
        this.cornerHeaderObjs = this._addCornerHeaders(
          colDimensionKeys,
          rowDimensionKeys,
          this.columnsDefine.concat(...this.rowsDefine, ...extensionRowDimensions)
        );
        
        ...
        
        this.setColumnширинаs();
    }
}    

```


### Create Scene Tree & Rendering

Create a scene tree, publish событиеs, и celebrate!

> `scenegraph.createSceneGraph()` actually belongs к the **rendering engine** (packвозрастs/vтаблица/src/scenegraph/scenegraph.ts), which is beyond the scope из this chapter, so it will не be analyzed в detail here.

```Typescript
// packвозрастs/vтаблица/src/сводныйтаблица.ts
export class сводныйтаблица extends Baseтаблица implements сводныйтаблицаапи {
    constructor(...) {
        ...
        
        // 生成单元格场景树
        this.scenegraph.createSceneGraph();
        
        // 为了确保用户监听得到这个事件 这里做了异步 确保vтаблица实例已经初始化完成
        setTimeout(() => {
            this.fireсписокeners(таблица_событие_TYPE.INITIALIZED, null);
        }, 0);
    }    
}    

```


## Process Summary


![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/RGnzwGRjAhmCgHbthx5cXdWLngR.gif)



# пользовательский Header


在[ Vтаблица 自定义表头章节](https://www.visactor.io/vтаблица/guide/таблица_type/сводный_таблица/пользовательский_header) 中，除了下面介绍了两种功能，还兼容了多种自定义维度树的 edge case，eg. 补全指标节点、自定义树不规则情况等。我们选取下面两种功能进行源码分析。    



## пользовательский Header Dimension Tree


### Requirements


в certain business scenarios, the business side may expect the row и column dimension trees к be displayed exactly as specified. в this case, Вы можете pass в the dimension trees using `rowTree` и `columnTree` к achieve this.    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/DZeCb7UjXosoZVxECiRcKY1Fnze.gif' alt='' ширина='1000' высота='авто'>



### Source код


*  данныеset    

* Вы можете see that if the user passes a пользовательский row header tree или column header tree, it is directly assigned к `данныеset.rowHeaderTree / colHeaderTree`    

```Typescript
export class данныеset {
    ...
    
    setRecords(records: любой[] | Record<строка, любой[]>) {
        ...
        
        if (this.пользовательскийRowTree) {
            this.rowHeaderTree = this.пользовательскийRowTree;
        }
        if (this.пользовательскийColTree) {
            this.colHeaderTree = this.пользовательскийColTree;
        }
      }
    }
}    

```


*  DimensionTree    

* Вы можете see that if the user passes a пользовательский row header tree и column header tree, the tree provided по the user will be directly used в `новый DimensionTree`    

* в fact, it is не using `данныеset.rowHeaderTree / colHeaderTree` к generate `DimensionTree` 

```Typescript
// packвозрастs/vтаблица/src/сводныйтаблица.ts
export class сводныйтаблица extends Baseтаблица implements сводныйтаблицаапи {
    constructor(...) {
        ...
        
        const keysResults = parseColKeyRowKeyForсводныйтаблица(this, options);
        let { columnDimensionTree, rowDimensionTree } = keysResults;
    }    
}

// packвозрастs/vтаблица/src/макет/макет-helper.ts
export функция parseColKeyRowKeyForсводныйтаблица(таблица: сводныйтаблица, options: сводныйтаблицаConstructorOptions) {
    
    if (options.columnTree) {
        columnDimensionTree = новый DimensionTree(
            **(таблица.internalProps.columnTree as ITreeмакетHeadNode[]) ?? [],**
            ...
        );
    }
    if (options.rowTree) {
        rowDimensionTree = новый DimensionTree(
            **(таблица.internalProps.rowTree as ITreeмакетHeadNode[]) ?? [],**
            ...
        );
    }
    
    возврат {
        ...
        columnDimensionTree,
        rowDimensionTree
    };
}    

```


* The subsequent process is consistent с the "tree display" process, which is к generate `макетMap` и create a scene tree    



## пользовательский Header Column Merging


### Requirements


в the node configuration из пользовательский `rowTree` и `columnTree`, there is a `levelSpan` поле that can be used к **specify the range из header cell merging**, с a по умолчанию значение из 1.    



*  case1: Set "Taobao flagship store" с `levelSpan: 2`    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/H9e7bFDploGmPsxbXAvccTXlneh.gif' alt='' ширина='1000' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Fr4EbJPGUoqds5xQAt8cq0RFntd.gif' alt='' ширина='1000' высота='авто'>



*  case2: Set "Taobao" с `levelSpan: 2`    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YQ1RbVMN3o9clmxsbzJcZuEhnQc.gif' alt='' ширина='1000' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/PPF4brVESoMIhWxdnfGc7aBnnid.gif' alt='' ширина='1000' высота='авто'>



от the two cases above, it can be seen that nodes с `levelSpan` set will **merge downwards** the corresponding level из cells; their descendant nodes will render normally, but the total depth из the header remains unchanged, и **nodes exceeding the depth will be скрытый**. The business side can set `levelSpan` as needed к render a more flexible пользовательский header tree.



### Source код

*  DimensionTree    

If `columnTree` is passed и `levelSpan` is set для a certain node, it will affect the logic из `DimensionTree.setTreeNode`.    

* Вы можете see `node.afterSpanLevel = node.afterSpanLevel + node.levelSpan`    

*  `level`: The actual level where the node is located    

*  `**afterSpanLevel**`: Calculate the level в the case из node spanning (+spanLevel)**    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Nktfblz6Xхорошо6ibxe3Yhc9TT2nac.gif' alt='' ширина='1000' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KdxibjVd2oHhA4xIcAAc07bVnkd.gif' alt='' ширина='680' высота='авто'>



*  сводныйHeaderмакетMap    

* It will affect the generation из `this._columnHeaderCellIds`. After traversing the column header tree through `this._addHeaders` и `dealHeader`, it is finally as shown в the figure below.    \r

<div style="display: flex;"><div style="flex: 37; отступ:5px;"><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/NOFmbYwAPoRgUIx1Gh4cWklfnWf.gif' alt='' ширина='1000' высота='авто'>
</div><div style="flex: 62; отступ:5px;"><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/SC3IbtJ4YoNtKvxSILBcGKsVn4f.gif' alt='' ширина='758' высота='авто'>
</div></div>


# Implementation из Typical Interactions


## развернуть & свернуть Dimension Tree


### Interaction Effects


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/T7aHbjZZpoGAoxxFSrbcMZqZnhG.gif' alt='' ширина='1000' высота='авто'>



### Source код

We take the пример из **collapsing dimension tree nodes** (`HierarchyState` от `развернуть` -> `свернуть`) для analysis.    



#### сводныйтаблица.toggleHierarchyState

This method is the entry point. Вы можете see:    \r

*  Actually calls `this._refreshHierarchyState()`    

*  After completion, publish the `сводный_таблица_событие_TYPE.TREE_HIERARCHY_STATE_CHANGE` событие    

```xml
toggleHierarchyState(col: число, row: число, recalculateColширинаs: логический = true) {
    const hierarchyState = this.getHierarchyState(col, row);
    if (hierarchyState === HierarchyState.развернуть) {
        **this._refreshHierarchyState(col, row, recalculateColширинаs);**
        **this.fireсписокeners(сводный_таблица_событие_TYPE.TREE_HIERARCHY_STATE_CHANGE,** {
            col: col,
            row: row,
            hierarchyState: HierarchyState.свернуть
        });
    } 
    ...
}    

```


#### сводныйтаблица._refreshHierarchyState

The core logic can be seen as:    \r

* Call `макетMap.toggleHierarchyState()` к get information about added, deleted, и modified rows    

* Finally, call `this.scenegraph.updateRow()` к trigger the scene tree к redraw the row    

```Typescript
_refreshHierarchyState(col: число, row: число, recalculateColширинаs: логический = true, beforeUpdateCell?: функция) {

    ...
    // 更新hover图标
    this.stateManвозрастr.updateHoverиконка(col, row, undefined, undefined);
    
    const isChangeRowTree = this.internalProps.макетMap.isRowHeader(col, row);
    // 获取 增、删、改 的行的信息
    const **result**: {
      addCellPositionsRowDirection?: CellAddress[];
      removeCellPositionsRowDirection?: CellAddress[];
      updateCellPositionsRowDirection?: CellAddress[];
      addCellPositionsColumnDirection?: CellAddress[];
      removeCellPositionsColumnDirection?: CellAddress[];
      updateCellPositionsColumnDirection?: CellAddress[];
    } = isChangeRowTree
      ? **(this.internalProps.макетMap as сводныйHeaderмакетMap).toggleHierarchyState(col, row)**
      : (this.internalProps.макетMap as сводныйHeaderмакетMap).toggleHierarchyStateForColumnTree(col, row);
      
    // 更新折叠图标
    this.scenegraph.updateHierarchyиконка(col, row);
    
    // 触发场景树更新行绘制
    **this.scenegraph.updateRow**(
        result.removeCellPositionsRowDirection,
        result.addCellPositionsRowDirection,
        result.updateCellPositionsRowDirection,
        recalculateColширинаs
     );
}    

```


#### сводныйHeaderмакетMap.toggleHierarchyState

Вы можете see that the logic из this функция is somewhat similar к the logic из the `сводныйHeaderмакетMap` constructor.

*  Reset `rowDimensionTree`    

* Call ` _addHeadersForTreeMode `** **к traverse the tree и recollect ` _rowHeaderCellFullPathIds `    

* Call `diffCellAddress` к collect information на added, deleted, и modified rows, и finally возврат 

```Typescript
export class сводныйHeaderмакетMap implements макетMapапи {
     // 点击某个单元格的展开折叠按钮 改变该节点的状态 维度树重置
     toggleHierarchyState(col: число, row: число) {
     
         this.rowDimensionTree.reset(this.rowDimensionTree.tree.children);
         this._rowHeaderCellFullPathIds_FULL = [];
         if (this.rowHierarchyType === 'tree') {
             // 递归树重新生成
             **this._addHeadersForTreeMode**(
                this._rowHeaderCellFullPathIds_FULL,
                0,
                this.rowDimensionTree.tree.children,
                [],
                this.rowDimensionTree.totalLevel,
                true,
                this.rowsDefine,
                this.rowHeaderObjs
             );
         }
         
         ...
         this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL);
         
         let diffCell: {
             addCellPositionsRowDirection?: CellAddress[];
             removeCellPositionsRowDirection?: CellAddress[];
             updateCellPositionsRowDirection?: CellAddress[];
             addCellPositionsColumnDirection?: CellAddress[];
             removeCellPositionsColumnDirection?: CellAddress[];
             updateCellPositionsColumnDirection?: CellAddress[];
         };
         if (this.rowHierarchyType === 'tree') {
             diffCell = diffCellAddress(
               col,
               row,
               oldRowHeaderCellIds.map(oldCellId => oldCellId[col - this.leftRowSeriesNumberColumnCount]),
               this._rowHeaderCellFullPathIds_FULL.map(newCellId => newCellId[col - this.leftRowSeriesNumberColumnCount]),
               oldRowHeaderCellPositons,
               this
             );
         }
         
         ...
         this.generateCellIdsConsiderHideHeader();
         
         ...
         возврат diffCell;
     }
}    

```


#### Scenegraph.updateRow

The general logic is as follows:    \r

* Call `updateRow()` method к add или delete rows    

* Call `this.recalculateColширинаs()` к recalculate column ширинаs    

* Call `this.компонент.updateScrollBar()` к update the scrollbar    

* Finally call `this.updateNextFrame()` к re-render    



### Process Summary


* The core logic is в `сводныйHeaderмакетMap.toggleHierarchyState`: it will recursively regenerate the tree к create новый header tree cell information (`_columnHeaderCellIds`, `_rowHeaderCellIds`); и collect information на added, deleted, и modified rows.    

*  Finally, re-render the таблица с the generated change information    





# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)
