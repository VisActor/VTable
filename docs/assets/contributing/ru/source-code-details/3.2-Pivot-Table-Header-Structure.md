---
заголовок: 3.2 сводный таблица Header Structure    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Overview

The макет из the сводный таблица headers is complex, с both column headers и row headers. This section will introduce the various modules из the сводный таблица headers, how these modules are interconnected, и the методы из generating каждый module.

## Scene Tree Related

Vтаблица manвозрастs таблицаs в the form из a scene tree. для a сводный таблица like the one below, there are three main sections regarding the header:

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/DRDubXl58хорошоr3GxTYJgcGSKRn7b.gif' alt='' ширина='1000' высота='авто'>

*  ColHeaderгруппа: список header Group, responsible для managing the список header part из the сводный таблица;

* RowHeaderгруппа: Row header Group, responsible для managing the row header part из the сводный таблица;

* CornerHeaderгруппа: Corner header Group;    

## макет Structure

### Structure Division

для сводный таблица headers, there are four core structures that form the framework из the header based на these structures.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/BRxJbn7dUocTINxNypqczzuEnLc.gif' alt='' ширина='1000' высота='авто'>

They are RowTree row dimension tree, ColumnTree column dimension tree, CornerHeader corner header, indicators.

* Row Dimension Tree

The row dimension tree is the dimension tree configuration provided по the user. Later, a corresponding row dimension tree instance `rowDimensionTree` will be created к manвозраст the развернуть и свернуть state из column headers, pagination configuration. The generation из the row header cell identification matrix also relies на the row dimension tree.



<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/SNQzbrJeJo5kRcxjWBMcZAvYnMh.gif' alt='' ширина='332' высота='авто'>

*  Column Dimension Tree    

The column dimension tree is the dimension tree configuration provided по the user, used к represent the hierarchical relationship из the список header. Later, it is necessary к generate the corresponding identification matrix и be responsible для the макет generation из the header, creating the `columnDimensionTree` instance.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/R7b9bFbAooBwn9xVyPzcmctEn4c.gif' alt='' ширина='1000' высота='авто'>

*  Corner Header    

The display format из corner headers is quite special, и there are three forms

* 'row' as the row dimension имя для the header cell content

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QF7zbxp3aocsGyxURxnc4BlVn1A.gif' alt='' ширина='328' высота='авто'>

* 'column' column dimension имя as corner cell content

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ArxQbJsFpo3NTmxEutSc6rhWnSc.gif' alt='' ширина='341' высота='авто'>

*  'все' corner cell content is a concatenation из row dimension имя и column dimension имя

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YUVrbSYIzot4h8xjMu7cwC5HnYg.gif' alt='' ширина='339' высота='авто'>

*  Metrics    

The generation из row dimension trees и column dimension trees will be affected по the metrics. Assuming the metrics are [ Продажи, Прибыль ], the dimension trees will be adjusted based на the позиция из the metrics during the generation process.

Assuming the metric is defined в the последний row из the column, when generating the column dimension tree, a metric column will be inserted below каждый leaf node.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WncEb2um2oUQ0WxL69fcKEzCnqb.gif' alt='' ширина='444' высота='авто'>

### Identity Matrix

в order к quickly и accurately locate the column или row information corresponding к a cell, the concept из an identification matrix is introduced within the сводный таблица.

The identity matrix is a two-dimensional matrix responsible для generating the макет structure из the header, as well as defining the positioning из cell columns, generating cell styles, и displaying values.

#### Column Header Identity Matrix

`_columnHeaderCellIds`    

* Two-dimensional массив structure, storing the globally unique ID из каждый cell в the column header

* каждый element corresponds к a cell в the column header area

* Hierarchical structure is implemented through nested arrays (e.g., `[[1,1,1], [2,3,4]]` represents two rows и three columns из column headers)

* Through this matrix, Вы можете quickly locate the row и column path information из a specific cell

*  The process из dragging the список header is actually changing this поле

* The calculation из colCount обязательный для generating таблицаs also depends на this поле

первый, recursively generate the corresponding `_columnHeaderCellIds` through the column dimension tree. When generating row headers, follow the rule из traversing columns первый и then rows к obtain the information из the corresponding cell through the row и column numbers, generate the текущий cell, и after completing the traversal, the corresponding список header is generated.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/CPg9bnGxIopNJpx1jg8c8ZcHnFc.gif' alt='' ширина='1000' высота='авто'>

#### Row Header Unit Identity Matrix

`_rowHeaderCellIds_FULL` и `_rowHeaderCellIds`

* Two-dimensional массив structure, storing the globally unique ID из каждый cell в the row header;    

*  ` _rowHeaderCellIds_FULL ` is responsible для storing the full identifier matrix, while ` _rowHeaderCellIds ` is only responsible для the row headers displayed на the текущий pвозраст;    

* в the process из dynamic pagination, pagination is achieved по changing `_rowHeaderCellIds`;    

* Able к quickly obtain the path information из a row header cell through the identification matrix;    

* Affects the calculation из the число из rows colCount that need к be generated для the таблица;    

`_columnHeaderCellIds` generation is completed, followed по the generation из `_rowHeaderCellIds_FULL`. The difference от the generation logic из `_columnHeaderCellIds` is that the generation из the row header cell matrix is transposed от the rows и columns.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KzJUbJonEo62wSxhUngcdmognkg.gif' alt='' ширина='1000' высота='авто'>

#### Corner Unit Identity Matrix

`_cornerHeaderCellIds`    

After the row header matrix и column header matrix are generated, the corner header cell identification matrix is generated. `_cornerHeaderCellIds` is responsible для

* Store the cell ID из the cross area из row и column dimensions

* Dynamically respond к changes в row и column dimensions (автоmatically clear when row и column dimensions are 0) 

Due к the particularity из corner headers, there are three forms из `cornerHeaderCellIds`:    

* 'row' as the row dimension имя в the header cell content

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/LXEubBvh1odKnFxyfHyc2dIMnAb.gif' alt='' ширина='603' высота='авто'>

*  'column' column dimension имя as corner cell content

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KOlBbkLEjoHpm6xqRhqcC6ctnke.gif' alt='' ширина='794' высота='авто'>

*  'все' corner cell content is a concatenation из row dimension имя и column dimension имя

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/CzrpbKjGQon7XOxgQA3cblFznkf.gif' alt='' ширина='779' высота='авто'>

### Header объект Mapping

Having only the identity matrix is не enough к generate the row и column headers because the definition данные corresponding к the cells cannot be obtained.

к achieve this, the сводный таблица internally maintains an объект mapping из the header, representing a mapping таблица из the unique ID из the cell и the текущий cell definition. Through the cell ID в the макет matrix (such as the values в `_columnHeaderCellIds`), an O(1) time complexity query can be achieved.

`_headerObjectMap` is responsible для managing the mapping из все row список headers;

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/NfN4b7JRDoS06dxlJkEc9kaunmh.gif' alt='' ширина='1000' высота='авто'>

для пример, if you want к get the display значение из a cell, you only need к provide col, row; then get the unique ID от the identification matrix, и then use the ID к get it от `headerObjectMap`, which can achieve the функция из obtaining the display значение из the cell.

```Typescript
// packвозрастs\vтаблица\src\макет\сводный-header-макет.ts
getHeader(col: число, row: число): Headerданные | SeriesNumberColumnданные {
    // ...
    const id = this.getCellId(col, row);
    возврат this._headerObjectMap[id as число] ?? { id: undefined, поле: '', headerType: 'текст', define: undefined };
    //...
}    

```
## Module Implementation Mechanism

### Row/список Header Identification Matrix

Here is the simplified generation logic, which is a depth-первый traversal process

```Typescript
// packвозрастs\vтаблица\src\макет\сводный-header-макет.ts
const _headerObjects = []; // 表头对象的映射
const _headerCellIds = [];
let colIndex = 0; // 表示叶子节点的个数
const columnHeaderObjs = {}; // 

функция _addHeaders(_headerCellIds, row, header, roots, results) {
  const _this = this;
  функция _newRow(row) {
    const newRow = (_headerCellIds[row] = []);
    if (colIndex === 0) {
      возврат newRow;
    }
    const prev = _headerCellIds[row - 1];
    для (let col = 0; col < prev?.length; col++) {
      newRow[col] = prev[col];
    }
    возврат newRow;
  }
  if (!_headerCellIds[row]) {
    _newRow(row);
  }

  для (let i = 0; i < header.length; i++) {
    const hd = header[i];
    dealHeader(hd, _headerCellIds, results, roots, row);
  }
}

функция dealHeader(hd, _headerCellIds, results, roots, row) {
  const id = hd.id;
  const cell = {
    id,
    заголовок: hd.значение,
    поле: hd.dimensionKey
  };
  results[id] = cell;
  _headerObjects[id] = cell;

  для (let r = row - 1; r >= 0; r--) {
    _headerCellIds[r][colIndex] = roots[r];
  }
  _headerCellIds[row][colIndex] = id;

  if (hd.children?.length >= 1) {
    _addHeaders(_headerCellIds, row + 1, hd.children ?? [], [...roots, id], results);
  } else {
    для (let r = row + 1; r < _headerCellIds.length; r++) {
      _headerCellIds[r][colIndex] = id;
    }
    colIndex++;
  }
}

_addHeaders(_headerCellIds, 0, columnsTree, [], columnHeaderObjs);    

```
* Prerequisites

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/TUWbbX0Fpo3oXxxji3Wc4Ce8nTd.gif' alt='' ширина='1000' высота='авто'>

* Specific process

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/AzjcwDJQOhp9z0bAU7icGRVsnBf.gif)

* пример

Let's take the row dimension tree structure provided above as an пример к see what exactly happened:

1. Initial state    

```javascript
_headerCellIds = []
colIndex = 0    

```
1. Handle the Northeast Регион (id=1)

```javascript
// 调用 _addHeaders(row=0)
_headerCellIds = [
  [1]  // row0
]
colIndex=0
// 发现子节点，递归调用 _addHeaders(row=1)    

```
1. Handle mailing method level one (id=2)

```javascript
_headerCellIds = [
  [1],  // row0
  [2]   // row1
]
colIndex=0
// 发现子节点，递归调用 _addHeaders(row=2)    

```
1. Process Продажи (id=3)

```javascript
// 处理叶子节点
_headerCellIds = [
  [1],  // row0
  [2],  // row1
  [3]   // row2
]
colIndex=1
// 填充下方行（如果有更多行）    

```
1. Process Прибыль (id=4), backfill the parent path upwards

```javascript
_headerCellIds = [
  [1, 1],  // row0
  [2, 2],  // row1
  [3, 4]   // row2
]
colIndex=2
// 返回上级继续处理    

```
1. в the same way, recursively handle the secondary mailing method (id=5), и backfill the parent path upwards

```javascript
_headerCellIds = [
  [1, 1, 1],  // row0
  [2, 2, 5],  // row1
  [3, 4, 5]   // row2
]
colIndex=2
// 处理子节点（id=6,7）...    

```
1. Handle mailing method level three (id=8)

```javascript
_headerCellIds = [
  [1, 1, 1, 1, 1, 1],  // row0
  [2, 2, 5, 5, 8, 8],  // row1
  [3, 4, 6, 7, 9, 10]  // row2
]
colIndex=6
// 完成东北地区处理    

```
1. Process North China Регион (id=11)

```javascript
_headerCellIds = [
  [...原东北列..., 11,11,11,11,11,11],  // row0
  [...原东北列...,12,12,15,15,18,18],   // row1  
  [...原东北列...,13,14,16,17,19,20]    // row2
]
colIndex=12    

```
1. Final state (after processing в the Central South Регион)

```javascript
_headerCellIds = [
  [1,1,1,1,1,1, 11,11,11,11,11,11, 21,21,21,21,21,21], // row0
  [2,2,5,5,8,8, 12,12,15,15,18,18, 22,22,25,25,28,28],  // row1
  [3,4,6,7,9,10,13,14,16,17,19,20,23,24,26,27,29,30]   // row2
]    

```
* Row header matrix

The process из generating a row header matrix is generally similar к that из a список header, except для an additional step из transposition в the конец.

### Corner Header Identification Matrix

The identification matrix из the corner header is simpler than the generation logic из the базовый таблица header, as it does не require recursion и only needs к traverse the row и column dimensions.

*  Source код     

```javascript
// packвозрастs\vтаблица\src\макет\сводный-header-макет.ts
  private _addCornerHeaders(
    colDimensionKeys: строка[] | null,
    rowDimensionKeys: строка[] | null,
    dimensions: (строка | IDimension)[]
  ) {
    const results: Headerданные[] = [];
    if (this.cornerSetting.titleOnDimension === 'все') {
      if (this.indicatorsAsCol) {
        let indicatorAtIndex = -1;
        if (colDimensionKeys) {
          colDimensionKeys.forEach((dimensionKey: строка, key: число) => {
              const cell: Headerданные = {
             // ...
            };
            results[id] = cell;
            this._headerObjects[id] = cell;

            if (!this._cornerHeaderCellFullPathIds[key]) {
              this._cornerHeaderCellFullPathIds[key] = [];
            
            для (let r = 0; r < this.rowHeaderLevelCount; r++) {
              this._cornerHeaderCellFullPathIds[key][r] = id;
            }
          });
        }
        if (rowDimensionKeys) {
          rowDimensionKeys.forEach((dimensionKey: строка, key: число) => {
            const id = ++this.sharedVar.seqId;
            const cell: Headerданные = {
             // ...
            };
            results[id] = cell;
            this._headerObjects[id] = cell;
            if (!this._cornerHeaderCellFullPathIds[indicatorAtIndex]) {
              this._cornerHeaderCellFullPathIds[indicatorAtIndex] = [];
            }
            this._cornerHeaderCellFullPathIds[indicatorAtIndex][key] = id;
          });
        }
      } else {
        let indicatorAtIndex = -1;
        if (rowDimensionKeys) {
          rowDimensionKeys.forEach((dimensionKey: строка, key: число) => {
            if (dimensionKey === this.indicatorDimensionKey) {
              indicatorAtIndex = key;
            }
            const id = ++this.sharedVar.seqId;
            const dimensionInfo: IDimension = dimensions.find(dimension =>
              typeof dimension === 'строка' ? false : dimension.dimensionKey === dimensionKey
            ) as IDimension;
            const cell: Headerданные = {
              id,
              // ...
            };
            results[id] = cell;
            this._headerObjects[id] = cell;

            для (let r = 0; r < this.columnHeaderLevelCount; r++) {
              if (!this._cornerHeaderCellFullPathIds[r]) {
                this._cornerHeaderCellFullPathIds[r] = [];
              }
              this._cornerHeaderCellFullPathIds[r][key] = id;
            }
          });
        }
        if (colDimensionKeys) {
          colDimensionKeys.forEach((dimensionKey: строка, key: число) => {
            const id = ++this.sharedVar.seqId;
            const dimensionInfo: IDimension = dimensions.find(dimension =>
              typeof dimension === 'строка' ? false : dimension.dimensionKey === dimensionKey
            ) as IDimension;
            const cell: Headerданные = {
              id,
                      // ...
            };
            results[id] = cell;
            this._headerObjects[id] = cell;
            this._cornerHeaderCellFullPathIds[key][indicatorAtIndex] = id;
          });
        }
      }
    } else if (this.cornerSetting.titleOnDimension === 'row' || this.cornerSetting.titleOnDimension === 'column') {
      const dimensionKeys = this.cornerSetting?.titleOnDimension === 'row' ? rowDimensionKeys : colDimensionKeys;
      if (dimensionKeys) {
        dimensionKeys.forEach((dimensionKey: строка, key: число) => {
          const id = ++this.sharedVar.seqId;
     
          const cell: Headerданные = {
            id,
         // ...
          };
          results[id] = cell;
          this._headerObjects[id] = cell;
          if (this.cornerSetting.titleOnDimension === 'column') {
            if (!this._cornerHeaderCellFullPathIds[key]) {
              this._cornerHeaderCellFullPathIds[key] = [];
            }
            для (let r = 0; r < this.rowHeaderLevelCount; r++) {
              this._cornerHeaderCellFullPathIds[key][r] = id;
            }
          } else if (this.cornerSetting.titleOnDimension === 'row') {
            для (let r = 0; r < this.columnHeaderLevelCount; r++) {
              if (!this._cornerHeaderCellFullPathIds[r]) {
                this._cornerHeaderCellFullPathIds[r] = [];
              }
              this._cornerHeaderCellFullPathIds[r][key] = id;
            }
          }
        });
      }
    } else {
      const id = ++this.sharedVar.seqId;
      const cell: Headerданные = {
        id,
         // ...
        }
      };
      results[id] = cell;
      this._headerObjects[id] = cell;
      для (let r = 0; r < this.columnHeaderLevelCount; r++) {
        для (let j = 0; j < this.rowHeaderLevelCount; j++) {
          if (!this._cornerHeaderCellFullPathIds[r]) {
            this._cornerHeaderCellFullPathIds[r] = [];
          }
          this._cornerHeaderCellFullPathIds[r][j] = id;
        }
      }
    }

    возврат results;
  }    

```
* Pre-process

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WHTFwcpEXh7C6TbuBrPc09Tqnuh.gif' alt='' ширина='820' высота='авто'>

* General Process

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/RrfVwZ0rchGPEMb5td9crzC9nwd.gif)

### Header объект Mapping

в the предыдущий process, corresponding cell definition nodes are continuously inserted into _headerObjects. Therefore, you only need к call reduce к transform the массив into a Map, completing the mapping из the базовый header объект.

```Typescript
// packвозрастs\vтаблица\src\макет\сводный-header-макет.ts
 this._headerObjectMap = this._headerObjects.reduce((o, e) => {
      o[e.id as число] = e;
      возврат o;
}, {} as { [key: макетObjectId]: Headerданные });
    

```
<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GH9ob52QdoxdBIxXBsOcT7IDnjg.gif' alt='' ширина='615' высота='авто'>

## Overall Header Generation Logic

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/RO3ab0gcGo3DnaxueT0cW34jnod.gif' alt='' ширина='1000' высота='авто'>

# This document is provided по Следующий personnel

taiiiyang( https://github.com/taiiiyang)     

# This document was revised и organized по Следующий personnel
 [玄魂](https://github.com/xuanhun)