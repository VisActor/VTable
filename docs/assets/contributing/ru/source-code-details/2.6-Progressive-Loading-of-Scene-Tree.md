---
заголовок: 2.6 Progressive загрузка из Scene Tree    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
ProgressProxy is a core submodule из the Scenegraph module в Vтаблица, primarily responsible для Производительность optimization в scenarios с large данные volumes. This module ensures smooth rendering и interactive experience under large данные volumes по controlling the creation и update process из scene nodes. This article aims к explore the practical characteristics из ProgressProxy по reading the source код.    \r

## Progressive загрузка Implementation Plan


### Control the число из Rendered Nodes для Progressive Creation


> код location: `Vтаблица\packвозрастs\vтаблица\src\scenegraph\group-creater\progress\proxy.ts`    

We know that Vтаблица has optimized the первый screen загрузка, и the idea из optimizing the первый screen actually has something в common с the optimizations we do в daily development. It базовыйally boils down к two directions: the первый is к reduce the число из rendering nodes, и the second is к improve the rendering speed. следующий, we will introduce how к limit the число из nodes.    \r

в the constructor из SceneProxy, the control logic для the число из nodes created для the первый screen, `createGroupForFirstScreen()`, is mainly reflected в the configuration из rowLimit и colLimit. Here, the maximum число из rows и columns maintained в the scene tree is limited. по limiting the число из nodes maintained simultaneously, memory usвозраст и rendering pressure are reduced, ensuring smooth Производительность even under large данные volumes.

```Typescript
constructor(таблица: Baseтаблицаапи) {
  this.таблица = таблица;

  if (this.таблица.isсводныйграфик()) {
    this.rowLimit = Math.max(100, Math.ceil((таблица.таблицаNoFrameвысота * 2) / таблица.defaultRowвысота));
    this.colLimit = Math.max(100, Math.ceil((таблица.таблицаNoFrameширина * 2) / таблица.defaultColширина));
  } else if (this.таблица.isавтоRowвысота()) {
    this.rowLimit = Math.max(100, Math.ceil((таблица.таблицаNoFrameвысота * 2) / таблица.defaultRowвысота));
  } else if (this.таблица.ширинаMode === 'автоширина') {
    this.colLimit = Math.max(100, Math.ceil((таблица.таблицаNoFrameширина * 2) / таблица.defaultColширина));
  } else {
    this.rowLimit = Math.max(200, Math.ceil((таблица.таблицаNoFrameвысота * 2) / таблица.defaultRowвысота));
    this.colLimit = Math.max(100, Math.ceil((таблица.таблицаNoFrameширина * 2) / таблица.defaultColширина));
  }
}    

```
The configured formula is для пример: `100, Math.ceil((таблица.таблицаNoFrameвысота * 2) / таблица.defaultRowвысота)`    

Such a calculation involves dividing the видимый area высота из the таблица по the row высота, which is the число из rows и columns that need к be displayed в real-time, then multiplying по two и using 100 as a fallback. The purpose из multiplying по two is к set a buffer, загрузка twice the число из nodes. While minimizing the число из rendered nodes, it also reserves space для scrolling up и down, ensuring that there is enough buffer before и after scrolling к avoid blank spaces due к загрузка delays.

### Specific Implementation Details из Incremental Creation


After configuring `rowLimit` и `colLimit`, how is progressive загрузка implemented?    

After reading, it was found that the core logic из progressive rendering lies в `setY` и `setX`, which are used к handle scrolling и progressive rendering в the vertical/horizontal directions, respectively. The main функция is к dynamically update the rows из the таблица based на the прокрутка позиция, ensuring that the rows в the currently видимый area are correctly rendered, while releasing the rows в the invisible area к save memory. Here, taking the vertical direction's SetY as an пример:

```Typescript
 async setY(y: число, isEnd = false) {
    const yLimitTop =
      this.таблица.getRowsвысота(this.bodyTopRow, this.bodyTopRow + (this.rowEnd - this.rowStart + 1)) / 2;
    const yLimitBottom = this.таблица.getAllRowsвысота() - yLimitTop;

    const screenTop = this.таблица.getTargetRowAt(y + this.таблица.scenegraph.colHeaderGroup.attribute.высота);
    if (screenTop) {
      this.screenTopRow = screenTop.row;
    }

    if (y < yLimitTop && this.rowStart === this.bodyTopRow) {
      // 执行真实body group坐标修改
      this.updateDeltaY(y);
      this.updateBody(y - this.deltaY);
    } else if (y > yLimitBottom && this.rowEnd === this.bodyBottomRow) {
      // 执行真实body group坐标修改
      this.updateDeltaY(y);
      this.updateBody(y - this.deltaY);
    } else if (
      (!this.таблица.scenegraph.bodyGroup.firstChild ||
        this.таблица.scenegraph.bodyGroup.firstChild.тип !== 'group' ||
        this.таблица.scenegraph.bodyGroup.firstChild.childrenCount === 0) &&
      (!this.таблица.scenegraph.rowHeaderGroup.firstChild ||
        this.таблица.scenegraph.rowHeaderGroup.firstChild.тип !== 'group' ||
        this.таблица.scenegraph.rowHeaderGroup.firstChild.childrenCount === 0)
    ) {
      this.updateDeltaY(y);
      // 兼容异步加载数据promise的情况 childrenCount=0 如果用户立即调用setScrollTop执行dynamicSetY会出错
      this.updateBody(y - this.deltaY);
    } else {
      // 执行动态更新节点
      this.dynamicSetY(y, screenTop, isEnd);
    }
  }    

```
The method itself первый calculates the верх limit `yLimitTop` и the низ limit `yLimitBottom` when scrolling, и maintains the index из the текущий верх line из the screen, which is the starting index для rendering, indicating от which line к начало rendering. Combined с the предыдущий context, по obtaining the starting index для rendering и the maximum число из lines restricted для rendering, we can slice out the local данные we need к render от the massive rendering данные.    

After obtaining the starting coordinates для rendering, implement rendering through некоторые update методы в the source код that начало с 'update'.



### Dynamic Updates


> код location: `Vтаблица\packвозрастs\vтаблица\src\scenegraph\group-creater\progress\update-positon`    

`dynamicSetY` method will dynamically load или unload rows based на the прокрутка позиция, ensuring that the rows в the currently видимый area are rendered correctly while releasing the rows в the non-видимый area к save memory.

```Typescript
export async функция dynamicSetY(y: число, screenTop: RowInfo | null, isEnd: логический, proxy: SceneProxy) {
  if (!screenTop) {
    возврат;
  }
  const screenTopRow = screenTop.row;
  const screenTopY = screenTop.верх;

  let deltaRow;
  if (isEnd) {
    deltaRow = proxy.bodyBottomRow - proxy.rowEnd;
  } else {
    deltaRow = screenTopRow - proxy.referenceRow;
  }
  move(deltaRow, screenTopRow, screenTopY, y, proxy);
  if (isEnd) {
    const cellGroup = proxy.таблица.scenegraph.highПроизводительностьGetCell(proxy.colStart, proxy.rowEnd, true);
    if (cellGroup.role === 'cell') {
      const deltaY =
        cellGroup.attribute.y +
        cellGroup.attribute.высота -
        (proxy.таблица.таблицаNoFrameвысота - proxy.таблица.getFrozenRowsвысота() - proxy.таблица.getBottomFrozenRowsвысота()) -
        y;
      proxy.deltaY = -deltaY;
      proxy.updateBody(y - proxy.deltaY);
    }
  }
  // proxy.таблица.scenegraph.updateNextFrame();
}    

```
The core design из the dynamicSetY method lies в achieving efficient и smooth progressive rendering по dynamically adjusting the row rendering range из the таблица. Its principle is based на real-time calculation из the прокрутка позиция и dynamic updating из row offsets, ensuring that the rows в the currently видимый area are correctly rendered while releasing the rows в the non-видимый area к save memory. The method первый obtains the information из the текущий screen's верх row through screenTop и determines whether it is scrolling или has ended based на the isEnd параметр, thereby calculating the row offset deltaRow. Then, it calls the move method к dynamically adjust the row rendering range из the таблица according к the row offset, ensuring that the таблица content is synchronized с the прокрутка позиция. в the конец из scrolling, the method further calculates the vertical offset deltaY и updates the coordinates из the body group к ensure the complete display из the таблица content. During large данные volume scrolling, the `ProgressProxy` module will dynamically update the scene nodes. During scrolling, в the direction из the прокрутка, некоторые cells will update their позиция в the scene tree и update the elements within the cells к complete the scrolling effect.



## Summary


We have concluded that the secret к Vтаблица maintaining high Производительность и a smooth user experience в large данные scenarios lies в the ProgressProxy module, which controls the таблица к render only the данные within the видимый range. It continuously calculates и dynamically updates interactions и данные updates during scrolling, making it one из the core modules для optimizing the Производительность из the таблица компонент.

# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)