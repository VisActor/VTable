---
заголовок: 6.3 списоктаблица код Structure и Detail Analysis    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Introduction


Common таблица компонент libraries are usually implemented based на the DOM, и there are very few таблица компонент libraries rendered based на Canvas. However, @Visactor/Vтаблица provides a таблица компонент library rendered based на Canvas. This article will начало с the implementation из various functions и interactions к see how списоктаблица relies на the capabilities provided по Canvas к achieve operations similar к native DOM.    \r

## списоктаблица External Dependencies


在对 списоктаблица 进行细节分析前，有必要先提下 списоктаблица 的外部依赖 [VRender](https://visactor.com/vrender)。VRender 是由 ByteDance 提供的一款可视化引擎，通过将 Canvas 的渲染图形的过程抽象成 Group 和 Stвозраст 进行管理，可以通过配置的形式在 Canvas 内部快捷的生成不同的图元。Group 可以理解成多个图元的组，Stвозраст 则对所有图元和 Group 进行管理，在下文中会经常提到这两个部分。    

## списоктаблица Architecture


первый, let's understand the general architecture. The базовый architecture из списоктаблица can be divided into Следующий modules    \r

* Rendering engine: Scenegraph scene tree. The movement из the header, graphic rendering, и cell ширина и высота calculation are все included в the scene tree; \r

* Progressive generation: The SceneProxy module is a submodule under Scenegraph, which defines the generation из the scene tree initialization, maintains the maximum row и column values generated during the initialization из the scene tree, и is responsible для the logic из scrolling progressive rendering; \r

* State Manвозрастment: StateManвозрастr handles the таблица state. навести и выбрать в списоктаблица exist в the form из данные. When the state changes, it triggers the Scenegraph к re-render the график; \r

*  событие System: событиеManвозрастr/событиеHandler handles interaction событиеs;    \r

* макет Manвозрастment: The core макет module из the макетMap таблица. It generates row список headers и maintains cell information through configuration; including the calculation из information для tree таблицаs и multi-level headers, все within the макет;    \r

*  макет calculation: Maintain row и column ширина и высота данные through colширинаsMap/rowвысотаsMap;    \r

*  Style system: Manвозраст styles through тема/style related modules;    \r

* данные Manвозрастment: Manвозраст records through данныеSource, including logic processing such as данные addition, deletion, modification, query, сортировкаing, и aggregation; \r

If Вы можете understand the above modules, you will be able к understand the general workflow из списоктаблица.

## базовый таблица макет Initialization


базовый таблицаs differ от the complexity из сводный таблицаs, consisting only из базовый rows и columns. для базовый таблица display, we only need к фокус на how many rows и columns need к be displayed, the logic из row и column макет generation, и how these rows и columns are mapped through данные.

The предыдущий article mentioned that the entire scene tree is created using `createGroupForFirstScreen` в the Vтаблица. We will analyze it directly от this функция.    

### createGroupForFirstScreen

```Typescript
// packвозрастs\vтаблица\src\scenegraph\group-creater\progress\create-group-для-первый-screen.ts
createGroupForFirstScreen(
  cornerHeaderгруппа: Group,
  colHeaderгруппа: Group,
  rowHeaderгруппа: Group,
  rightFrozenгруппа: Group,
  bottomFrozenгруппа: Group,
  bodyгруппа: Group,
  xOrigin: число,
  yOrigin: число,
  proxy: SceneProxy
 ) {
*  // 阶段1：参数初始化*
  proxy.setParamsForRow(); *// 计算行的更新位置，行更新的数量和新的范围*
  proxy.setParamsForColumn(); *// 计算列的更新位置，列更新的数量和新的范围*
  
  *// 阶段2：计算首屏渲染范围*
  *// 列范围计算逻辑*
  distCol = Math.min(proxy.firstScreenColLimit - 1, таблица.colCount - 1);
  *// 行范围计算逻辑*
  distRow = Math.min(proxy.firstScreenRowLimit - 1, таблица.rowCount - 1);
  
  *// 阶段3：自适应计算（首次渲染需要精确计算）*
  if (未手动调整列宽) {
    computeColsширина(таблица, 0, distCol); *// 计算列宽*
  }
  if (未手动调整行高) {
    computeRowsвысота(таблица, 0, distRow); *// 计算行高*
  }
  
  *// 阶段4：定位容器组*
  таблица.scenegraph.colHeaderGroup.setAttribute('x', таблица.getFrozenColsширина());
  таблица.scenegraph.bodyGroup.setAttributes({
    x: таблица.getFrozenColsширина(),
    y: таблица.getFrozenRowsвысота()
  });
  
  *// 阶段5：填充列容器（核心）*
  *// 5.1 填充角表头*
  createColGroup(cornerHeaderGroup, ...);
  
  *// 5.2 填充顶部表头*
  createColGroup(colHeaderGroup, ...);
  
  *// 5.3 填充左侧表头（含行号列）*
  createColGroup(rowHeaderGroup, ...);
  
  *// 5.4 填充 body group*
  createColGroup( ... , bodyGroup, ... );
  
  //... 填充剩下的容器
  *// 阶段6：启动渐进渲染*
  if (有数据) {
    proxy.progress(); *// 启动异步渲染任务*
  }
}    

```
It can be seen that after the process из createGroupForFirstScreen is completed, the scene tree is filled. Internally, `createColGroup` is continuously called к achieve container filling.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/TnsOwzt8ThFyIxbLHrzcdfnmn7g.gif' alt='' ширина='814' высота='авто'>

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">It is especially noteworthy that this функция only involves the filling из the column container. The initialization из the container is located в initSceneGraph, which will be called when initializing the scene graph.    
The file is located в Vтаблица\packвозрастs\vтаблица\src\scenegraph\group-creater\init-scenegraph.ts    
</div>
### createColGroup

*  packвозрастs\vтаблица\src\scenegraph\group-creater\column.ts    

Generate a column scene node, call `createComplexColumn` к populate the ColumnGroup according к the начало и конец columns, и update the высота из каждый column.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QPOMw4BcwhAuoRbbibtc20WznAd.gif' alt='' ширина='820' высота='авто'>

### createComplexColumn

*  packвозрастs\vтаблица\src\scenegraph\group-creater\column-helper.ts    

Create a graphic element для каждый row based на the range из rows, и it will be divided into common cell groups according к the rows.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/RNefwa6gjhAX1ibVmkBcAz9dnob.gif' alt='' ширина='789' высота='авто'>

### createCell

от the internal import, it can be found that createCell is the creation closure из the cell container. createCell will create a cell based на the passed configuration и insert it into the corresponding column container, generating different primitives according к different types.

```Typescript
// packвозрастs\vтаблица\src\scenegraph\group-creater\cell-helper.ts
import тип { CreateграфикCellGroup } от './cell-тип/график-cell';
import тип { CreateImвозрастCellGroup } от './cell-тип/imвозраст-cell';
import тип { CreateProgressBarCell } от './cell-тип/progress-bar-cell';
import тип { CreateSparkLineCellGroup } от './cell-тип/spark-line-cell';
import тип { CreateTextCellGroup } от './cell-тип/текст-cell';
import тип { CreateVideoCellGroup } от './cell-тип/video-cell';    

```
### базовый таблица макет Organization Full Process


от the above logic, the базовый display process из VTbale первый creates все the necessary containers, including the header container и the body container. Then, it iterates through the columns к create header column containers, configures каждый row к create cell containers, и then creates body column containers, continuing к configure rows к generate cell containers.

Simply put, первый create каждый structure container, then create column containers, и finally the cells.    \r

### Verification


We print the значение в createCell к see if the creation order is the same as we analyzed.

*  packвозрастs\vтаблица\src\scenegraph\group-creater\cell-helper.ts    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YNuobIX1eoRwNtxfKadcEEzVnVh.gif' alt='' ширина='934' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Mou3bafYiowc9PxSmGycKRnpnsc.gif' alt='' ширина='1000' высота='авто'>

Observe the console output, perfectly validating our предыдущий analysis.    

## данные Presentation


### Get the значение из a cell


After discussing the макет process из базовый таблицаs, let's see how базовый таблицаs obtain the `значение` that needs к be displayed в каждый cell.    

Returning к the previously mentioned `createComplexColumn`, Вы можете see that before creating a cell, it always calls таблица.getCellValue к get the display значение из the текущий cell. для a базовый таблица, таблица represents списоктаблица.    

```Typescript
// packвозрастs\vтаблица\src\scenegraph\group-creater\column-helper.ts
export функция createComplexColumn() { 
    // 省略
    let значение = таблица.getCellValue(col, row);
    // 省略
}    

```
для the cells в the body section, the lowest level из `списоктаблица.getCellValue` will use _currentPвозрастrIndexedданные, which represents the index из records corresponding к каждый row на the текущий pвозраст. It will be updated в the `данныеSource.updatePвозрастrданные` method based на pagination и `currentIndexedданные`.    

Due к the existence из `currentPвозрастrIndexedданные`, when you want к get the cell значение, you only need к find the record в the original данные through the index из the текущий row, и then Вы можете match the original значение из the cell according к the column index.    

As для obtaining the значение из the header cell, it directly retrieves the corresponding configuration от _headerObjectMap, indirectly obtaining the title от columns, then performs некоторые special processing на it, и uses it as the значение из the header cell. The specific process will не be elaborated here. \r

### currentIndexedданные

Regarding currentIndexedданные, it has already been mentioned before. Here, we will emphasize its meaning и usвозраст again.    \r

Due к the various interaction методы из списоктаблица, such as row и column transposition и tree structure, it is very difficult к obtain cell values. Therefore, списоктаблица introduces currentIndexedданные (*the index из the source данные corresponding к каждый row*) к assist в данные processing.    \r

Let's take a tree structure as an пример    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/He2Vb8ZAuoOs6ExoXDZcLqFin9e.gif' alt='' ширина='622' высота='авто'>

His currentIndexedданные loхорошоs like this.    

```Typescript
[
  0, // 数据源对应第1条数据 紧邻其下的是第1条数据的子节点 说明第1条数据被展开了
  [0, 0], // 数据源对应第1条下的 第1个子节点
  [0, 1], // 数据源对应第1条下的 第2个子节点
  1, // 数据源对应第2条数据
  [1, 0], // 以此类推 。。。
  [1, 1], 
  [1, 2], 
  [1, 3], 
  2, 
  [2, 0], 
  [2, 1], 
  3
];    

```
So how к use currentIndexedданные? Вы можете refer к the данныеSource.getValueFromDeepArray method. для пример, к get the данные из the second row, the reading method is таблицаInstance.данныеSource.records[0].children[0], which corresponds к [0,0].

по abstracting the direct reading или modification из raw данные into a form из adjusting и retrieving the corresponding row record through an index, без needing к modify the original данные, it allows для focusing only на the index corresponding к каждый row when updating the макет, без worrying about the original данные, thus reducing cognitive load.

## Transpose из Rows и Columns


### Concept


Transposing rows и columns is к swap the rows и columns из a таблица, и this feature is only доступный в базовый таблицаs.    \r

Unlike other таблица компонент libraries based на native DOM that require complex пользовательскийization к achieve transposition функциональность, списоктаблица can включить row-column transposition с just one configuration. Let's see how списоктаблица implements this feature.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/OOwVbOIdioM6yKxiNvDcNu8Nnfd.gif' alt='' ширина='803' высота='авто'>

### Scene Tree Creation Process


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/JEzpbEUmMomBGvx6gEScbsvbnIc.gif' alt='' ширина='1000' высота='авто'>

по observing the calls к getCellValue, it is found that the creation process из the scene tree remains the same.    

### Post-transposition Processing


Think about how к handle the transposed данные, two obvious методы come к mind:    \r

1. Directly change records     

1. Specially handle данные reading based на whether к transpose или не    \r

списоктаблица internally adopts the second solution. The reason для не adopting the первый solution is that there is too much dependency на records internally, including данные addition, deletion, modification, и query. If records are directly modified, it affects many areas, не к mention the situation where users need к frequently modify данные, which requires compatibility в many places.    \r

We use the transpose matrix в linear algebra для comparison. A transpose matrix is where the число из rows becomes the число из columns, и the число из columns becomes the число из rows. Originally, values were accessed using records[row][col], but now they should be accessed using records[col][row].

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/EKbFbIU4moqsxSxXWzmca06Inxg.gif' alt='' ширина='832' высота='авто'>

Originally, the header was determined по row, now it needs к be determined по col.    

```Typescript
// packвозрастs\vтаблица\src\макет\simple-header-макет.ts
  isHeader(col: число, row: число): логический {
    if (
      this.transpose &&
      col >= this.leftRowSeriesNumberColumnCount &&
      col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount
    ) {
      возврат true;
    }
    if (!this.transpose && row >= 0 && row < this.headerLevelCount) {
      возврат true;
    }
    возврат false;
  }    

```
от the special handling part из transpose within списоктаблица, transposition не only affects the judgment logic из the header и body parts, but also affects the conversion из the число из rows и columns, the adjustment из col и row when fetching данные, и the calculation из таблица ширина и высота в multiple places.    \r

## Tree Structure


### фон из Use


When users need к view hierarchical данные, a tree structure is used.    \r

Below is an пример из a списоктаблица tree structure:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ByhEbnFLto9DPfxbsqtceMx6nvh.gif' alt='' ширина='622' высота='авто'>

### Configuration


списоктаблица uses commonly used данные configurations в the market, implementing a tree structure по nesting данные с `children` и specifying the `tree` attribute в `columns`.    

### Tree таблица Processing


![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/X86Kw3Xjqhp35YbXdHFcOz4cnne.gif)

Process Analysis    

1. Parse опция:     

1. When initializing the макетMap, the rowHierarchyType will be dynamically adjusted based на whether the column configuration includes a tree поле или a groupBy configuration. Subsequent special judgments will be made based на the rowHierarchyType.    

```Typescript
// packвозрастs\vтаблица\src\макет\simple-header-макет.ts
export class SimpleHeaderмакетMap implements макетMapапи {
  constructor() {
    // 省略
    this.rowHierarchyType = checkHasTreeDefine(this) ? 'tree' : 'grid';
  }
}    

```
1. When rowHierarchyType is true, it will call initTreeHierarchyState к initialize the по умолчанию cell expansion state, adjusting **hierarchyState** (the expanded/collapsed state из the cell tree structure) и **hierarchyExpandLevel** (the число из levels expanded в the tree structure)    \r

1. Handle макет: Calculate the placeholder макет для the свернуть/развернуть Кнопка, и позиция the content display based на the hierarchyIndent distance configured по the user для child nodes;    \r

1. данные processing: Special handling из tree-structured данные is обязательный, including logic для adding, deleting, updating, querying, и сортировкаing;    \r

Taking сортировкаing as an пример, списоктаблица internally performs Следующий steps для the tree structure:    

1. Get the column к be сортировкаed, списоктаблица supports multi-column сортировкаing;    \r

1. If there is cached данные от the предыдущий сортировкаing, use it directly (cache optimization, this cache will be cleared when the данные is updated)    \r

1. Traverse все the columns к be сортировкаed obtained от the первый step, сортировка the первый layer из the tree structure, и adjust currentIndexedданные; the сортировкаing standard из списоктаблица is based на the column Нажатьed первый;    \r

1. Traverse от верх к низ, call pushChildrenNode sequentially к сортировка the child nodes, и then insert the сортировкаed данные under the parent node;    \r

1. Recursively call pushChildrenNode к continuously сортировка the child nodes;    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/DZ2Tw5BLyhNkUnbGbKncJaoZnnc.gif)

Here is the currentIndexedDatra after Нажатьing the Категория для ascending order, Вы можете clearly see the corresponding change, `Furniture` is placed before `Technology`:    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/MnTYwk2jAhJq1hbdO6McdtdVnXi.gif)

1. событие Binding: по binding the иконка_Нажать событие, when Нажатьing the развернуть/свернуть иконка, call таблица.toggleHierarchyState к adjust the таблица, while maintaining currentIndexedданные, и report the corresponding событие и parameters к the user through a обратный вызов.    

1. таблица rendering: макет according к таблица column definitions    

1. When rendering nodes, determine the развернуть/свернуть state и adjust the node's иконка accordingly; use the развернуть/свернуть state (hierarchyState) к determine the node's иконка. Note that the root node's hierarchyState is никто, so there is no иконка;

1. Adjust the indentation значение из the cells и the calculation method из the column ширина according к the level;    \r

1. Asynchronous загрузка: When dealing с large данные volumes, set children к true к включить asynchronous rendering. списокen к the развернуть и свернуть событиеs из the tree structure и manually call setRecordChildren к insert данные.    \r

### Calculation из Indentation


Regarding the indentation из tree structures, it affects two parts: one is the calculation logic из indentation within the cell, и the other is the calculation из the cell's автоmatic ширина.    

*  Calculate column ширина    

в the core logic из calculating column ширина, there is a section из код specifically для handling indentation.    \r

计算公式用伪代码表示：`cellHierarchyIndent = 当前的缩进层级 * hierarchyIndent + 展开收起图标的宽度`

Subsequently, when calculating the column ширина, this cellHierarchyIndent will be added к the original cell length.    \r

```Typescript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-col-ширина.ts
функция computeавтоColширина(...): число {
      // 省略
      *// 基本表格表身body单元格 如果是树形展开 需要考虑缩进值*
      const define = таблица.getBodyColumnDefine(col, row);
      if ((define as ColumnDefine)?.tree) {
        const indexArr = таблица.данныеSource.getIndexKey(таблица.getRecordShowIndexByCell(col, row));
        cellHierarchyIndent =
          массив.isArray(indexArr) && таблица.getHierarchyState(col, row) !== HierarchyState.никто
            ? (indexArr.length - 1) * ((макетMap as SimpleHeaderмакетMap).hierarchyIndent ?? 0)
            : 0;
         // 省略
      }
      // 省略
 }    

```
*  Cell internal indentation calculation    

в the process из creating a текст cell (createTextCellGroup), there is an internal call к a method `getHierarchyOffset`.    

It involves the calculation из the indentation offset значение (cellHierarchyIndent), с the formula `cellHierarchyIndent = текущий indentation level * hierarchyIndent + ширина из the развернуть/свернуть иконка`. This formula can be used к derive the indentation offset, thereby positioning the текст during cell generation и adjusting the offset значение в the x direction.    

### State Transition


As mentioned earlier, the базовый таблица internally manвозрастs данные through currentIndexedданные. Let's первый loхорошо в what changes occur when a node is expanded using currentIndexedданные:    \r

* Нажать `envelope` before    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WKruwwasthgYXRbK1lMcJUqXnue.gif' alt='' ширина='814' высота='авто'>

* Нажать `信封` after    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/R3KawuIYuh4tRDbf99Mc3p4Lnvb.gif)

It is clearly seen that two lines из данные, [0,0,0] и [0,0,1], are inserted under the `envelope`; they represent the `yellow envelope` и `white envelope` respectively.    

*  Observe again the output из getCellValue when Нажатьing the `envelope` к развернуть:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/OvVJbYo8Xop2iRxi5e3cMiFFnYb.gif' alt='' ширина='1000' высота='авто'>

What can be seen is that все cells below the `envelope` were updated первый, и then other column containers для `envelope` children were created.    

---
для the expansion переключить из nodes, it can be abstracted into Следующий steps:    

1. Parent node иконка переключить: Adjust the hierarchyState из nodeданные к change the развернуть/свернуть иконка;    \r

1. Insertion и deletion из child nodes:    

1. When expanding, recursively call `pushChildrenNode` к insert child nodes и update currentIndexedданные;    

1. When deleting, recursively call `computeChildrenNodeLength` к calculate the число из affected lines, и directly delete currentIndexedданные;    

1. данные Update: Update _currentPвозрастrIndexedданные through currentIndexedданные;    \r

1. Update the число из rows и columns: Adjust the число из rows и columns through _currentPвозрастrIndexedданные;    \r

1. Update the scene tree: Call `scenegraph.updateRow` к update the scene tree;    

1. Trigger the обратный вызов `TREE_HIERARCHY_STATE_CHANGE` passed в по the business party;    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/NHiewfuLBhmOzdb7R1cc2Fbhn7f.gif' alt='' ширина='820' высота='авто'>

## Grouping


### Scenario Analysis


базовый таблица grouping display функция is applicable к various scenarios, для пример:    \r

* Financial statements: Can be grouped и displayed according к different account types (such as income, expenses, assets, liabilities) к help better understand the financial situation.    \r

* Продажи данные analysis: It can be grouped по product Категория, Регион, Продажиperson, etc., making it easy к compare и analyze the Продажи Производительность из different categories или Регионs.    \r

### Case


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KGNybWmjLo7CAsx8VPIcFn5qnwf.gif' alt='' ширина='1000' высота='авто'>

```Typescript
  const данные = [
    {
      категория: 'Office Supplies',
      'Sub-Категория': 'Paper',
      'Product имя': 'Messвозраст Boхорошо, Wirebound, Four 5 1/2" X 4" Forms/Pg., 200 Dupl. Sets/Boхорошо'
    },
    {
      категория: 'Office Supplies',
      'Sub-Категория': 'Labels',
      'Product имя': 'Avery 508'
    }
  ];
  
  const option = {
    records: данные,
    columns,
    ширинаMode: 'standard',
    groupBy: ['Категория', 'Sub-Категория'],
    enableTreeStickCell: true
  };    

```
The expansion и свернуть из tree structures have been discussed earlier. в the grouping section, we will фокус на the данные processing part.

### Internal данные Processing


Let's observe the currentIndexedданные в the пример above. It is obvious that it has five rows, but only two rows were passed в during initialization в records. It is easy к see that списоктаблица internally inserted three rows для us, which represent the group headers generated internally по списоктаблица. \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/F7WibbJPuouRYbxshuLc9BSPnkh.gif' alt='' ширина='699' высота='авто'>

currentIndexedданные has changed, indicating that records have definitely been adjusted. Let's take another loхорошо в `таблицаInstance.данныеSource.records`, which is clearly quite different от the original records passed в.    

The списоктаблица converts the original two-dimensional массив structure into a tree structure и автоmatically groups it.

```javascript
[
    {
        "vтаблицаMerge": true,
        "vтаблицаMergeимя": "Office Supplies",
        "children": [
            {
                "vтаблицаMerge": true,
                "vтаблицаMergeимя": "Paper",
                "children": [
                    {
                        "Категория": "Office Supplies",
                        "Sub-Категория": "Paper",
                        "Product имя": "Messвозраст Boхорошо, Wirebound, Four 5 1/2\" X 4\" Forms/Pg., 200 Dupl. Sets/Boхорошо"
                    }
                ],
                "hierarchyState": "развернуть"
            },
            {
                "vтаблицаMerge": true,
                "vтаблицаMergeимя": "Labels",
                "children": [
                    {
                        "Категория": "Office Supplies",
                        "Sub-Категория": "Labels",
                        "Product имя": "Avery 508"
                    }
                ],
                "hierarchyState": "развернуть"
            }
        ],
        "hierarchyState": "развернуть"
    }
]    

```
Note that there are several special полеs в the tree structure, имяly:    \r

*  hierarchyState: This поле, mentioned earlier, indicates the текущий node's развернуть/свернуть state;    \r

*  vтаблицаMerge: Indicates whether it is a merged cell. для merged cells, списоктаблица will have special handling;    \r

*  vтаблицаMergeимя: имя из the merged cell;    \r

---
Through the above analysis, we can understand what списоктаблица does internally для grouping.    \r

So how does списоктаблица group two-dimensional данные к form a tree structure? This involves the grouping algorithm within списоктаблица.    

### Core Grouping Algorithm


The core из the internal grouping algorithm из списоктаблица is dealWithGroup     

#### параметр Parsing


This method receives five parameters    

```javascript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
функция dealWithGroup(record, children, map, groupByKeys, level) { ... }    

```
*  record - The данные record currently being processed;    \r

*  children - The массив из child nodes в the текущий level. Before processing все records, a верх-level groupResult is generated as children, и subsequently, child elements are inserted recursively;    \r

*  map - The mapping таблица из the `следующий level group значение` и `corresponding index в the group node children` из the текущий group node; a separate one is maintained в каждый level из the group node, и when the same group значение is encountered later, it will be directly inserted в the same index;    \r

* groupByKeys - массив из grouping полеs, groupBy passed в option; \r

*  level - The текущий processing group level    

#### Group Node


Это general structure из a grouped node    

```javascript
{
      vтаблицаMerge: true,
      vтаблицаMergeимя: значение,
      children: [] as любой,
      map: новый Map()
}    

```
Among them:    

*  vтаблицаMergeимя: The grouping значение corresponding к the текущий record, для пример, such a piece из данные    \r

```javascript
{
  категория: 'Office Supplies',
  'Sub-Категория': 'Paper',
  'Product имя': 'Messвозраст Boхорошо, Wirebound, Four 5 1/2" X 4" Forms/Pg., 200 Dupl. Sets/Boхорошо'
}    

```
If the groupKey corresponding к the текущий level is `Категория`, then для the grouping node в this level, the vтаблицаMergeимя is `Office Supplies`    

*  vтаблицаMerge: Due к grouping, для group headers, it is always assumed that the entire row needs к be merged;    \r

*  children: The children corresponding к the текущий group, as there may be multiple groups, it is a tree structure;    \r

* map: A mapping таблица из the group values и their corresponding indices в the children under the текущий group node, ensuring that the same subgroup can be quickly inserted into the correct позиция when encountered следующий time.    \r

Taking the grouping в the пример above as an пример, the outermost Map loхорошоs like this. This means that if данные от the Office Supplies -> Paper group is encountered later, it can be directly inserted into children[0].


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KMiMbcDaSoAXNIxuM47cNju3nWf.gif' alt='' ширина='706' высота='авто'>

#### Pre-process Flow


```Typescript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
// 省略
const groupMap = новый Map();
const groupResult = [] as любой[];
для (let i = 0; i < records.length; i++) {
  dealWithGroup(records[i], groupResult, groupMap, groupByKeys, 0);
}
возврат groupResult;
// 省略    

```
Before traversing the records, an outermost groupMap и groupResult are generated. The groupResult serves as the первый layer из the tree structure. Due к address referencing, все subsequent record insertions will be inserted into the groupResult. After traversing каждый данные entry и completing dealWithGroup, the groupResult is returned as the final records.    \r

#### dealWithGroup Recursive Process


1. первый, obtain the текущий groupKey и determine whether it has reached the последний level. If it is the последний level, directly insert it into children, indicating that the recursion is complete:

```Typescript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
  if (!isValid(groupByKey)) {
    children.push(record);
    возврат;
  }
  // ...    

```
1. Use groupByKey к get the значение и determine which group the текущий record belongs к в this level;    \r

```Typescript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
  const значение = get(record, groupByKey);    

```
1. Use map к determine whether the текущий значение (group значение) exists в the `children` из the предыдущий group node (i.e., the children passed в the текущий closure). If it exists, it means that this group has already appeared, и the same node is reused и passed as children к the следующий recursive logic;    \r

```Typescript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
if (map.has(значение)) {
  const index = map.get(значение);
  возврат dealWithGroup(record, children[index].children, children[index].map, groupByKeys, level + 1);
}    

```
1. If the map does не exist, it means there is no corresponding group node, и a новый group node needs к be created. Then update the map из the предыдущий group node, и append the новый node к the конец из `children из the предыдущий group node` (i.e., the children passed в the текущий closure). Use this newly created node as the children параметр для the следующий recursion, because the текущий record has been determined к belong к this group. возврат the result after recursive processing.

```Typescript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
map.set(значение, children.length);
children.push({
  vтаблицаMerge: true,
  vтаблицаMergeимя: значение,
  children: [] as любой,
  map: новый Map()
});
возврат dealWithGroup(
  record,
  children[children.length - 1].children,
  children[children.length - 1].map,
  groupByKeys,
  level + 1
);    

```
в this point, the dealWithGroup для a single record has been completed. Below is the corresponding flowграфик:    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WRuAwvF0JhY8TebvI88c7VgBnkb.gif)

#### Case Study


Let's take the records above as an пример. After processing the первый record, let's see the status из groupResult и groupMap:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/HKq3bJWbGoS8kZxDeFIcAoxmngf.gif' alt='' ширина='1000' высота='авто'>

Вы можете see that the первый record has been correctly grouped и inserted into groupResult[0].children[0], и the index corresponding к the `Office Supplies` group has already been stored в groupMap.    

So when inserting the second record, a новый group node will не be created в the первый level, but в the second level `Sub Категория` level, since there is no record из the `Labels` node в `children[0].map`, a новый `Paper` node will be created, и the record will be placed в the children corresponding к that node.    

If there is more данные, it will follow this pattern. After processing все records, the final groupResult will be assigned к `таблицаInstance.данныеSource.records`, completing the grouped данные processing.


Since каждый node maintains a Map individually, the time complexity is greatly reduced during the recursion process.    

## Classic Interaction


As mentioned earlier, the underlying layer из Vтаблица is based на VRender, и most interactions are implemented по списокening к событиеs provided по VRender. Let's начало с a few classic interactions к see how списоктаблица achieves interactions comparable к native DOM по списокening к событиеs provided по VRender.    \r

### перетаскивание к Adjust Column ширина


The regular way к adjust column ширина mainly involves списокening к three событиеs:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/HbwWwpEphhkyORbRwS0cxyEwnlf.gif' alt='' ширина='820' высота='авто'>

However, в the Vтаблица, adjusting the column ширина mainly relies на pointer событиеs:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/SzFVwZKpdhlQCbb8IPGcd6Iynwb.gif' alt='' ширина='804' высота='авто'>

The main reason для using pointer событиеs is that pointer не only supports mouse событиеs but also supports все pointer devices such as stylus и touch screens, providing better compatibility.    

#### начало dragging к adjust column ширина

The activation из dragging column ширина mainly списокens к the pointerdown событие из the таблицаGroup. The overall process is roughly as follows:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Xp4Ew3iaphfPMmbbRHEcE1wynCc.gif' alt='' ширина='820' высота='авто'>

##### Dragging Hotspot Judgment


You might be curious about how списоктаблица internally determines whether the текущий Нажать is на a граница или a cell. Let's take a loхорошо в how списоктаблица makes this determination.    \r

Determine whether the Нажатьed area is within the перетаскивание hotspot, mainly relying на scenegraph.getResizeColAt, which contains a core piece из код.

```Typescript
// packвозрастs\vтаблица\src\scenegraph\scenegraph.ts
if (abstractX < cellGroup.globalAABBBounds.x1 + offset) {
  // 命中 左边界
  cell = { col: cellGroup.col - 1, row: cellGroup.row, x: cellGroup.globalAABBBounds.x1 };
} else if (cellGroup.globalAABBBounds.x2 - offset < abstractX) {
  // 命中 右边界
  cell = { col: cellGroup.col, row: cellGroup.row, x: cellGroup.globalAABBBounds.x2 };
}    

```
*  globalAABBBounds: The boundary information из the текущий cell, x1 is the лево boundary, x2 is the право boundary    \r

*  abstractX: The X coordinate из the текущий Нажать позиция    \r

*  offset: Dragging hotspot ширина (resizeHotSpotSize)    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ZIJCbkIYVorwzhxVUUScY3YVncf.gif' alt='' ширина='683' высота='авто'>

Let's take the лево boundary as an пример:    

The текущий Нажатьed X coordinate < the X coordinate из the лево boundary из the cell + resizeHotSpotSize means hitting the лево перетаскивание hotspot, в this time you need к update the information из the текущий перетаскивание cell к the лево cell, the same applies к the право перетаскивание hotspot.

Below is the overall flowграфик из getResizeColAt    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QCEHwmw6whebzNbXsHlckNCrnkb.gif' alt='' ширина='820' высота='авто'>

If Вы можете get the cell information Нажатьed through getResizeColAt, it means that the boundary из a certain column has been hit, и Вы можете continue the action из dragging the column ширина.    \r

##### Impact из startResizeCol


The startResizeCol в the предыдущий step will update the columnResize state в the StateManвозрастr, и later в the pointermove событие, it can determine whether the column ширина is being dragged по checking resizing.    

It will also record the x-coordinate и column index в the начало из the перетаскивание.    \r

```Typescript
// packвозрастs\vтаблица\src\state\state.ts
  startResizeCol(col: число, x: число, y: число, isRightFrozen?: логический) {
    this.columnResize.resizing = true;
    this.columnResize.col = col;
    this.columnResize.x = x;
    this.columnResize.isRightFrozen = isRightFrozen;
    this.таблица.scenegraph.компонент.showResizeCol(col, y, isRightFrozen);
  }    

```
#### Dragging


Handling the перетаскивание process mainly relies на the pointermove событие. Below is the logic для entering и binding related перетаскивание событиеs.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Nx4BwnFM9hUicdbwZnWclWg3ntc.gif' alt='' ширина='820' высота='авто'>

*  bindContainerDomсписокener    

списоктаблица списокens к the pointermove событие в the body и passes в globalPointermoveCallback as a обратный вызов.    

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\container-dom.ts
bindContainerDomсписокener() { 
    // ... 
    document.body.addсобытиесписокener('pointermove', globalPointermoveCallback);
}    

```
*  globalPointermoveCallback    

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\container-dom.ts
функция globalPointermoveCallback() {
  // ...
  if (stateManвозрастr.interactionState === InteractionState.grabing) {
      if (stateManвозрастr.isResizeCol()) {
        событиеManвозрастr.dealColumnResize(x, y);
        if ((таблица as любой).hasсписокeners(таблица_событие_TYPE.RESIZE_COLUMN)) {
          таблица.fireсписокeners(таблица_событие_TYPE.RESIZE_COLUMN, {
            col: таблица.stateManвозрастr.columnResize.col,
            colширина: таблица.getColширина(таблица.stateManвозрастr.columnResize.col)
          });
        }
      }
  }
  // ...
 }    

```
The обратный вызов will internally determine whether it is в the state из dragging the column ширина, then call dealColumnResize, и subsequently trigger the обратный вызов событие configured по the business side.    

##### Real-time Column ширина Update Mechanism


Why is списоктаблица so smooth when adjusting column ширинаs? The main processing logic is still в dealColumnResize. и the execution из dealColumnResize is actually executing updateReizeColumn.    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/HdyUwBmcHhMB1wbbqICcCeXNnmd.gif)

##### Column ширина Update Process

Updating column ширина mainly involves three functional functions    

*  updateReizeColumn（packвозрастs\vтаблица\src\state\изменение размера\update-изменение размера-column.ts）    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/XLFjwjbkhhMofBbzsZmcAkgsn4b.gif)

*  updateResizeColForColumn（packвозрастs\vтаблица\src\state\изменение размера\update-изменение размера-column.ts）    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Dlx9wIZiNh2dh6bqP1kcnbO8n5c.gif)

*  updateColширина （packвозрастs\vтаблица\src\scenegraph\макет\update-ширина.ts）    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GHdLwtjgyh3mlGbInwIc7jcWntg.gif)

##### Special Handling в Adaptive Mode


базовый таблицаs can включить adaptive mode с `ширинаMode: 'adaptive'`. в this case, the length из the таблица is fixed, и Вы можетеnot update just one column alone; instead, columns на both sides из the baseline need к be updated.

Assuming the user has dragged the baseline к the право, the offset из the перетаскивание is deltaX, which is deltaX для the лево column и `-deltaX` для the право column.

```Typescript
// packвозрастs\vтаблица\src\state\изменение размера\update-изменение размера-column.ts
функция updateResizeColForColumn(detaX: число, state: StateManвозрастr) {
    // ...
    state.таблица.scenegraph.updateColширина(state.columnResize.col, detaX);
    state.таблица.scenegraph.updateColширина(state.columnResize.col + 1, -detaX);
    // ...
 }    

```
<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/SKAXbuwcvoNCjhxdYlJcDBSknfc.gif' alt='' ширина='905' высота='авто'>

#### перетаскивание и отпускание Completed

The перетаскивание completion списокens к the pointerup событие. Since the график has already been updated during the перетаскивание process, there isn't much к do when the перетаскивание is completed. The main tasks are operations like restoring the state к по умолчанию values, specifically including:    \r

1. Restore stateManвозрастr.columnResize state    

1. Update interactionState к the по умолчанию значение     

`stateManвозрастr.updateInteractionState(InteractionState.по умолчанию);`    

1. скрыть baseline    

1. Trigger RESIZE_COLUMN_END событие    

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointerup', (e: FederatedPointerсобытие) => {
    //...
    if (stateManвозрастr.interactionState === 'grabing') {
      stateManвозрастr.updateInteractionState(InteractionState.по умолчанию);
      if (stateManвозрастr.isResizeCol()) {
        endResizeCol(таблица);
      } 
    // ...
  });    

```
#### Overall Process


![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ACoVwofb1h3lJWbieQIcdjyxnZg.gif)

### Column перетаскивание и отпускание Replacement

#### Configuration


Business parties can включить перетаскивание-и-отпускание header rearrangement through the dragHeaderMode configuration, but для перетаскивание-и-отпускание header rearrangement, it is limited к the same level и cross-level dragging is не allowed. \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/H8QrbEqz6onC6fx5kBuceikkn3e.gif' alt='' ширина='845' высота='авто'>

#### перетаскивание и отпускание списокener


The списокener для перетаскивание-и-отпускание repositioning is the same as the списокener для перетаскивание-и-отпускание column ширина adjustment, both списокening к the pointerdown событие.    \r

However, в this обратный вызов, it will первый determine whether it hits the перетаскивание к adjust column ширина, к avoid affecting the перетаскивание column ширина событие.    \r

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointerdown', (e: FederatedPointerсобытие) => {
  //...
  *// 处理column mover*
  if (событиеManвозрастr.chechColumnMover(событиеArgsSet)) {
       stateManвозрастr.updateInteractionState(InteractionState.grabing);
       возврат;
  }
  //...
}    

```
*  chechColumnMover    

```Typescript
// packвозрастs\vтаблица\src\событие\событие.ts
  chechColumnMover(событиеArgsSet: Sceneсобытие): логический {
    const { событиеArgs } = событиеArgsSet;
    if (
      событиеArgs &&
      this.таблица._canDragHeaderPosition(событиеArgs.col, событиеArgs.row)
    ) {
      this.таблица.stateManвозрастr.startMoveCol(...);
      возврат true;
    }
    возврат false;
  }    

```
#### Whether к Enter Dragging


Due к the particularly complex logic из dragging и swapping columns, the criteria для determining whether к enter dragging are very strict. The diagram below shows the logic для determining whether к enter column перетаскивание swapping:    \r

*  _canDragHeaderPosition(packвозрастs\vтаблица\src\core\Baseтаблица.ts)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Xq86wVNcxhbHsRbeymIcu49Vn9c.gif' alt='' ширина='820' высота='авто'>

There is a special judgment internally. If the текущий configuration's headerSelectMode is 'cell' или the range does не include the entire column when multiple rows are selected, dragging is не allowed. This judgment is mainly added к resolve the conflict between dragging к выбрать multiple headers и dragging columns.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YAXfbxCEPo5KQQxS6wtcsg4BnVc.gif' alt='' ширина='550' высота='авто'>

#### Initialize Dragging Process


*  startMoveCol （packвозрастs\vтаблица\src\state\cell-move\index.ts）    

When it is determined к be a column перетаскивание событие, three things will be done internally:    \r

1. Update the stateManвозраст.columnMove status, record the текущий starting row и column число из the перетаскивание, и update moving к true;    

1. Display the текущий перетаскивание-и-отпускание order adjustment компонент    

1. Clear selected state    

#### перетаскивание Validity


##### Prerequisite Scenario

Assume we have a таблица header с 3 rows и 6 columns    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/хорошоf0b4m7nogjkbxnocNcYX3Jnxe.gif' alt='' ширина='664' высота='авто'>

списоктаблица maintains a _headerCellIds в the макетMap module (таблица макет module), и the _headerCellIds corresponding к the header above loхорошоs like this:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KYMLb2RyCoaeO8xDuxVchJaPnXc.gif' alt='' ширина='679' высота='авто'>

##### Transposition Rule


As mentioned earlier, the sourceCol is recorded в the начало из the перетаскивание, и the targetCol is also obtained в real-time during the перетаскивание. The main функция из списоктаблица is к determine whether the parent IDs из the two are consistent к decide if swapping is possible.


The core logic из this part is located в `макетMap.canMoveHeaderPosition`:    

*  

```Typescript
// packвозрастs\vтаблица\src\макет\simple-header-макет.ts
  canMoveHeaderPosition(source: CellAddress, target: CellAddress): логический {
  // ... 
      const sourceTopId = this.getParentCellId(source.col, sourceCellRange.начало.row);
      const targetTopId = this.getParentCellId(target.col, sourceCellRange.начало.row);
      возврат sourceTopId === targetTopId;
  // ...
  }    

```
для пример:    

* sourceCell is B1, targetCell is B2, directly use _headerCellIds к get the parent ID    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WHUVb4cPdo0fPmx7IRLcCvEnnmb.gif' alt='' ширина='664' высота='авто'>

*  sourceTopId：    

B1 is the sourceCell, col is 1, row is 1, the entire cell sourceCellRange is \r

```Typescript
начало = {col: 1, row: 1}
конец = {col: 1, row: 2}    

```
Get parent ID as 2 based на source.col = 1 и sourceCellRange.начало.row = 1, sourceTopId = 2    \r

*  targetTopId：    

B2 is the targetCell, col is 3, row is 1, \r

According к target.col = 3 и sourceCellRange.начало.row = 1, get parent ID as 2, targetTopId = 2    \r

* The two IDs are the same, they can be swapped    

* sourceCell is B2, targetCell is C1, directly use _headerCellIds к get parent ID \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/IqtNbajm7oIBQyx1rxzczMpbn6c.gif' alt='' ширина='664' высота='авто'>

*  sourceTopId:    

B2 is the sourceCell, col is 2, row is 1, sourceCellRange is     \r

```Typescript
конец = {col: 3, row: 1}
начало = {col: 2, row: 1}    

```
Get parent ID as 2 based на source.col = 2 и sourceCellRange.начало.row = 1, sourceTopId = 2    \r

*  targetTopId:    

C1 is the targetCell, col is 4, row is 1    

Get parent ID as 7, targetTopId = 7 based на target.col = 4 и sourceCellRange.начало.row = 1    \r

* The two IDs are different, swapping is prohibited    

---
It is very obvious that when swapping, the row число is judged using the row число из the starting cell. This is because it is assumed that dragging will only occur в the same level, so theoretically, only the column (col) changes during the dragging process.    \r

##### Purpose из _headerCellIds Cache

макетMap maintains a _headerCellIds, partly к facilitate obtaining relationships between nodes. для пример, when obtaining a parent node, if the текущий cell's path is `headerCellIds[row][col]`, then the parent ID can be directly obtained using `headerCellIds[row - 1][col]`.

#### Dragging Process


Unlike the обратный вызов для dragging к adjust column ширина, the style update для column перетаскивание-и-отпускание rearrangement is done в the pointermove событие обратный вызов из the таблицаGroup. The actual update occurs в the pointerup событие.

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Lxzpw5fqqhkrztbhp6scarIBnme.gif)

#### _headerCellIds Update Mechanism

When the перетаскивание событие is completed, _headerCellIds will be dynamically updated. The update logic here is quite complex. Let's take B1 -> B2 as an пример к see how the update из _headerCellIds is completed.

1. первый, obtain the число из columns contained в the starting cell according к sourceCellRange, sourceSize;    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WKdEbLBkmowNI6xGLkTcKDwKnYf.gif' alt='' ширина='793' высота='авто'>

1. Get the column targetIndex для the insertion target address. Here, two situations need к be considered:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/MSzrb1QwwoNKjjxKDWxcOYSsnoe.gif' alt='' ширина='793' высота='авто'>

1. The target column is к the лево из the starting column, targetIndex = targetCellRange.начало.col;    \r

1. The target column is к the право из the starting column, targetIndex = targetCellRange.конец.col - sourceSize + 1;    

в this case, targetIndex = 3 - 1 + 1 = 3;    

1. Traverse _headerCellIds line по line     

1. первый line:     \r

1. _headerCellIds The первый row, от the beginning column из sourceCellRange, removes the length из sourceSize, и takes the removed elements as sourceIds     \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KKUabsDRloCHnox6uQlc4lbjnpd.gif' alt='' ширина='811' высота='авто'>

1. Then insert 0 и targetIndex в the beginning из sourceIds;    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/CafobZllBouDgxxbnIvcpbisnNO.gif' alt='' ширина='258' высота='авто'>

1. Call `массив.prototype.splice.apply(this._headerCellIds[row], sourceIds)`; equivalent к `this._headerCellIds[row].splice(3, 0, 2)`, after this step, _headerCellIds will be 

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/SFLxbIhs3o2y8qxgJVlc8ZPzn4b.gif' alt='' ширина='790' высота='авто'>

Abstracting к the график, it is actually equivalent к moving все cells after sourceIndex forward, и then moving the starting cell к the targetIndex позиция.

1. Second line    

1. Extract sourceIds    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/X72xb3ya8oJLuqxNIkXchS2xnHf.gif' alt='' ширина='811' высота='авто'>

1. Insert 0 и targetIndex    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/KQQObiGpuoFkb1xbSj5chh49nWh.gif' alt='' ширина='258' высота='авто'>

1. Insert sourceIds into targetIndex     

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Fve6bsFphouBTmxRdSYcoNn1nmh.gif' alt='' ширина='795' высота='авто'>

1. Similarly, after updating the third line, the _headCellIds loхорошоs like this. в this point, the adjustment из the данные index part для dragging и swapping columns is complete.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/UQkTbUD0Go0KsQxmQGMcDf3TnPh.gif' alt='' ширина='805' высота='авто'>

#### Overall General Process


![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/BJ4Vw42ckhLMkqb2JoNcqKhtn9b.gif)

### таблица Scrolling


#### фон из the Requirement


The native таблица компонент library can directly use the browser's built-в scrolling effect, whereas для Canvas, it does не автоmatically generate прокрутка bars, nor does it have corresponding scrolling logic, let alone create virtual scrolling effects like native DOM. все scrolling effects need к be manually calculated. Let's take a loхорошо в how списоктаблица achieves scrolling effects по списокening к Canvas событиеs.

#### Scrolling Scheme

списоктаблица supports two scrolling методы, имяly dragging the scrollbar и using the mouse wheel. Essentially, these two scrolling методы are the same, с the difference being the trigger point:    \r

##### Wheel Scrolling

The прокрутка wheel relies на the wheel событие provided по Stвозраст, allowing you к obtain the текущий прокрутка offset during scrolling, и then progressively load таблица elements during the scrolling process.    \r

Here is a general process about wheel scrolling:    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/AhcIwRW4KhcIcWbSlx1cW7ncndg.gif)

##### перетаскивание the scrollbar

The scrollbar uses the ScrollBar компонент provided по VRender, и списокens к the прокрутка событие к complete the scrolling logic; the handling during the перетаскивание process is roughly the same as the logic из the mouse wheel scrolling, the core is к complete the progressive загрузка из the scene graph through `this.таблица.scenegraph.setY`;

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/VF0pw7of0h0jJubejYxcWjIMnFc.gif' alt='' ширина='820' высота='авто'>

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Cnf1wO8хорошоhoG7ab5iwRcRtKTnsA.gif)

Since the user manually drags the scrollbar к trigger it, there is no need к update the позиция из the scrollbar. Moreover, only one direction will exist в the same time, и the corresponding direction is already known before entering the logic.

#### прокрутка Offset Optimization


During the process из wheel scrolling, there is a функция `optimizeScrollXY`, which is mainly used к optimize the scrolling direction по converting near-horizontal или vertical scrolling into a single direction, avoiding the interference caused по diagonal scrolling.    

##### Formula


* ANGLE = 2, defined as the slope threshold для direction determination    \r

*  Obtain the slope angle through `x ``/ y`    

* Optimized deltaX = angle <= 1 / ANGLE ? 0 : x    

* Optimized deltaY = angle > ANGLE ? 0 : y    

##### Core Processing

* When the absolute значение из `x/y` is less than или equal к 0.5 (i.e., 1/ANGLE), it is considered vertical scrolling, и the horizontal increment is cleared.    

* When the absolute значение из `x/y` is greater than 2 (i.e., ANGLE), it is considered horizontal scrolling, и the vertical increment is cleared    

* The intermediate angle retains the original increment (considered as diagonal scrolling)    

Simply put, only those с a slope between 0.5 и 2 will retain their original values; otherwise, they will все be reset к a single direction.    

##### Case

Let's loхорошо в how `optimizeScrollXY` is optimized through Следующий case studies.    

*  Significant vertical scrolling (y-direction increment is much greater than x)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/NZDnbBQ27ozVQMxL0KXcmq2YnSh.gif' alt='' ширина='494' высота='авто'>

Reset к vertical scrolling    

* Significant horizontal scrolling (x-direction increment is much greater than y)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/CYdGbCO5doXyMLxnT5Ica9KAn8e.gif' alt='' ширина='680' высота='авто'>

Reset к horizontal scrolling    

*  45-degree diagonal прокрутка (x/y=1)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/HiMnb2GsIohVI3x9cBccVu1XnXq.gif' alt='' ширина='679' высота='авто'>

Preserve original значение    \r

#### Progressive загрузка


Since the smoothness из списоктаблица scrolling is reflected в the frame rate, the more frames that can be displayed в one second, the smoother the таблица scrolls. к increase the frame rate, it is necessary к optimize данные processing during scrolling к ensure more frames can be used к re-render the график. для this reason, списоктаблица implements progressive загрузка для scrolling. During scrolling, it does не simply adjust the x и y coordinates but achieves scrolling по dynamically adjusting the cells. Let's take a loхорошо в how списоктаблица specifically implements this:    \r

##### Entry File

The previously mentioned setY и setX методы are the core logic для implementing scrolling в the таблица. The entry points для these two методы are в the scenegraph module, where they actually call the setX и setY методы в SceneProxy.    \r

```Typescript
// packвозрастs\vтаблица\src\scenegraph\scenegraph.ts
  */***
*   * @description: 设置表格的x位置，滚动中使用*
*   * @возврат {*}*
*   */*
  setX(x: число, isEnd = false) {
    this.таблица.scenegraph.proxy.setX(-x, isEnd);
  }

  */***
*   * @description: 更新表格的y位置，滚动中使用*
*   * @param {число} y*
*   */*
  setY(y: число, isEnd = false) {
    this.таблица.scenegraph.proxy.setY(-y, isEnd);
  }
    

```
##### SceneProxy

Regarding the SceneProxy module, it is a submodule из SceneGraph и is created during the initialization из SceneGraph. This module is mainly responsible для calculating the maximum число из rows и columns из the scene tree, progressive загрузка из the scene tree, и the logic для creating the первый screen group.    \r

Let's take setY as an пример, here is the flowграфик из setY:    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/LXmMw6A5VhIx0cb4aS7cbJAyn1e.gif)

The core logic из progressive updates is dynamicSetY.    

##### Dynamic Update из Scene Tree


*  packвозрастs\vтаблица\src\scenegraph\group-creater\progress\update-позиция\dynamic-set-y.ts    

The core logic из progressive загрузка is located в dynamicSetY. следующий, let's see what dynamicSetY does.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/AtiTwmweFhsR1ObM0escwgj7nx5.gif' alt='' ширина='820' высота='авто'>

##### Core Implementation Principle

в списоктаблица, there is also cell reuse operation. The preliminary process из dynamicSetY mainly determines the range из updates, и the actual update logic is located в updateCellGroupPosition. \r

Let's take sliding down as an пример. в the списоктаблица, the первый cell will be taken out, the y-значение из the CellGroup will be updated, и then the cell will be inserted into the конец из the ColGroup. If the число из cells that need к be updated has been calculated beforehand, this operation will be repeated multiple times.    \r

This operation can avoid frequent creation из cells, и you only need к update the позиция из the cell.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QE4dbH4zkoagirxcJjic0WeZntc.gif' alt='' ширина='1000' высота='авто'>

## Summary


This article starts с the списоктаблица module и describes the underlying implementation logic из most functions и interactions в списоктаблица.    

от the analysis из the above structures, it can be seen that списоктаблица has made many Производительность optimizations, including the indexing и storвозраст из данные; mapping таблицаs для different groups в the grouping algorithm к reduce the time complexity из node insertion; indexing и storвозраст из header данные к reduce the time complexity из processing headers; и progressive загрузка из the scene tree during scrolling, etc.

# This document is provided по Следующий personnel


taiiiyang( https://github.com/taiiiyang)     



# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)