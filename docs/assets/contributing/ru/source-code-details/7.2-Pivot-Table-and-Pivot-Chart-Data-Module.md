---
заголовок: 7.2 сводный таблица и сводный график данные Module    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Overview


данные processing is one из the core steps из данные visualization. This section will introduce how сводныйтаблица organizes и processes данные, enabling данные к support efficient rendering из сводныйтаблица while also possessing сводныйтаблица данные analysis capabilities.



## автоmatic Organization из Dimension Tree


### фон из the Requirement

Using our diagram:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/HspObuOYNoVbBlxpJv0c87D9nXt.gif' alt='' ширина='1000' высота='авто'>

Suppose we want к implement such a multidimensional таблица, generally speaking, the parameters we expect от the business side are:

1. Well-organized dimension trees RowTree, ColumnTree (similar к `timeTree` и `channelTree`) \r

1. Specific данные records under various dimensions и indicators    \r



в theory, it can be achieved, but the drawbacks are also obvious: **the business side needs к assemble the данные into this structure по themselves, which has a high integration cost**. We expect the business side к only pass concise Records с некоторые simple configurations, и we can parse the данные ourselves и render it into a multidimensional таблица. для пример, the Records passed в are the original данные found от the db:    \r

```xml
const records = [
    {
        channel: "线上",
        platform: "淘宝",
        shop: "淘宝旗舰店",
        month: 3,
        day: 2,
        curr_price: 3999
    },
    {
        channel: "线上",
        platform: "京东",
        shop: "京东三方店",
        month: 3,
        day: 3,
        origin_price: 4399,
    },
    ...
]    

```


<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">Objective: Transform the original данныеset `Records` through данные processing к obtain a данные structure that supports display в сводный таблица format    
</div>


### Implementation Approach

#### Analysis


с the above фон и objectives, некоторые questions may easily arise:    \r

1. How к generate `rowTree`, `columnTree` от raw данные?    

1. Answer: Group aggregation. Similar к `SQL`'s `group`, theoretically we can сортировка out the values из каждый dimension от `records` в a way similar к `group` (e.g., group aggregation к find the dimension values under `platform` such as `"Taobao" | "JD" | "Douyin"`).

1. How к ensure the lowest time complexity и pursue Производительность when the данные volume из `records` is large?    



#### Approach


*  Convention для user-provided данные & данные structure    

```xml
const данныеsetOptions = {
  // 原始数据
  records: [
    {
      channel: '线上',
      platform: '淘宝',
      shop: '淘宝期间店',
      month: 3,
      week: 1,
      day: 3,
      origin_price: 4399,
    },
    {
      channel: '线上',
      platform: '淘宝',
      shop: '淘宝三方店',
      month: 3,
      week: 1,
      day: 4,
      curr_price: 4099
    }
    ...
  ],
  // rowTree 和 columnTree 中各维度层次在原始数据中的key
  columns: ['channel', 'platform', 'shop'],
  rows: ['month', 'week', 'day'],
  // 指标在 原始数据 中的key
  indicatorKeys: ['origin_price', 'curr_price']
};
    

```
* Task    

* Collect dimension members (e.g., under the `platform` dimension there are `"Taobao" | "JD" | "Douyin"` three members)    

*  Assemble `rowTree`, `columnTree`    

*  When rendering, quickly **search** для the corresponding данные из the cell от `records` (as shown в the figure)    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/SiuZbu4rpoVNFJx5S5QcwD98nKh.gif' alt='' ширина='1000' высота='авто'>



Theoretically, based на the known tasks:    \r

* Traversing the `records` once can accomplish the task из "collecting dimension members"; based на the collected dimension members и the `columns`, `rows`, `indicatorKeys` passed в по the user, theoretically, it is possible к assemble the rowTree и columnTree.    

*  But how do we know the parent-child relationship из these dimensions? How do I know that the `shop` dimension is actually a sub-dimension из the `platform` dimension?    \r

* When users pass `columns`, the parent dimension should be **сортировкаed** before the child dimension, e.g.:    

```xml
// ❌ bad 
const options = {
  columns: ['channel', 'shop', 'platform'],
  ...
};

// ✅ good
const options = {
  columns: ['channel', 'platform', 'shop'],
  ...
};    

```


*  But the issue из "quickly finding the corresponding данные от `records` when rendering" is quite troublesome. Suppose we know the row dimension + column dimension из the cell, we need к implement the `getCellValue(col: число, row: число)` функция. Do we have к iterate over `records` again? That would be too cumbersome.    

* The most efficient method: по leveraging the capabilities из a `**hash map**`, the time complexity из loхорошоup can be reduced к `O(1)`. So how к design the structure из a `hash map`?    \r



в fact, the данные area is a two-dimensional matrix, so Вы можете use `(row, col)` к locate the позиция из каждый cell. Therefore, if we have a two-dimensional `hash map`, its structure is roughly as follows, which can be used к loхорошо up cell данные.

```xml
// HashMap 的第一层 key 为 row，第二层 key 为 col
тип HashMap = Record<строка, Record<строка, IndicatorValue[]>>

// 指标值
тип IndicatorValue = {
    indicatorKey: строка;
    значение: строка;
}    

```


в our requirement, how do we define the structure из a `hash map` с two layers из keys? к ensure uniqueness, we can use the строка composed из the `path` от `root` к `leaf node` в `rowTree` и `columnTree` as the key (as shown в the diagram и код below).

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GLPabQm3mo2H8NxhzRxcbhmOnqd.gif' alt='' ширина='1000' высота='авто'>

```xml
// 指标值
тип IndicatorValue = {
    indicatorKey: строка;
    значение: строка;
}

// TreeMap 的第一层 key 为 row-path，第二层 key 为 col-path
тип TreeMap = Record<строка, Record<строка, IndicatorValue[]>>

// 数据维度 tree 对象
const tree: TreeMap = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: "origin_price",
                значение: '4299'       
            }
            {
                indicatorKey: "curr_price",
                значение: '3999'       
            }
        ]
    }
}    

```


### данные Parsing Process


с the above analysis, let's go through the данные parsing process    \r



#### Traverse `Records` & create dimension tree объект

Variables к maintain during данные traversal:    

```xml
// 列维度成员组成的数组
colKeys: строка[][]
// 行维度成员组成的数组
rowKeys: строка[][]    

```
<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ODRAbOpf1o8o2UxmGnRcQCUfnge.gif' alt='' ширина='1000' высота='авто'>



During the process из traversing the данные, a `dimension tree объект` (also referred к as a `hash map` в the предыдущий текст; для consistency, it will be referred к as a "dimension tree объект" below) will also be generated.    

```xml
// 数据维度 tree 对象
// 第一层 key 实际就是 colKeys 的元素，再 join 得到的字符串
// 第二层 key 为 rowKeys 的元素经过 join 得到的字符串
tree: Record<строка, Record<строка, IndicatorValue[]>> = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: "origin_price",
                значение: '4299'       
            }
            {
                indicatorKey: "curr_price",
                значение: '3999'       
            }
        ]
    }
}    

```


#### Search


с the `dimension tree объект`, during rendering, Вы можете quickly find the corresponding данные для the cell от `records`.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/DbykbT4qMo7EruxJdIicXZmrnbg.gif' alt='' ширина='1000' высота='авто'>



### Source код

According к the above analysis process, let's take a loхорошо в how the source код is implemented.

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">код entry: `packвозрастs/vтаблица/src/данныеset/данныеset.ts`
Следующий код has been simplified

</div>


*  setRecords: Entry method для данные processing    

* processRecords: Process данные, iterate through все entries    

*  **processRecord**: Process **a single piece из данные**, we have implemented most из the analysis process в this функция    \r



#### Traverse `Records` & create dimension tree объект

> в предыдущий assumptions, we imagined that the dimension path would be 'online-Taobao-Taobao flagship store', which would be problematic because dimension members might also contain the '-' строка.  
> в the source код, `строка.fromCharкод(0)` is used as the separator для the dimension path, i.e., `\u0000`. в JavaScript, `\u0000` represents the character с Uniкод encoding `U+0000`, which is the **null character (null Character)**. This character is usually used к indicate the конец из a строка или as a placeholder, but it is typically не displayed в actual rendering. Here, it is mainly used к ensure the uniqueness из the dimension path строка.  

```xml
class данныеset {
    colKeys: строка[][] = [];
    rowKeys: строка[][] = [];
    private colFlatKeys: Record<строка, число> = {}; // 记录某个colKey已经被添加到colKeys
    private rowFlatKeys: Record<строка, число> = {}; // 记录某个rowKey已经被添加到rowKeys
    tree: Record<строка, Record<строка, Aggregator[]>> = {};
    
    stringJoinChar = строка.fromCharкод(0); // 维度 path 的分隔符
    
    setRecords(records: любой[] | Record<строка, любой[]>) {
        this.processRecords();
        
        ...
    }
    
    // 处理数据, 遍历所有条目
    private processRecords() {
        ...
        для (let i = 0, len = this.records.length; i < len; i++) {
            const record = this.records[i];
            
            ...
            this.processRecord(record);
        }
    }
    
    // 处理单条数据
    private processRecord(record: любой, assignedIndicatorKey?: строка) {
        ...
      
        const colKeys: { colKey: строка[]; indicatorKey: строка | число }[] = [];
        const rowKeys: { rowKey: строка[]; indicatorKey: строка | число }[] = [];
        
        // 收集维度成员
        const rowKey: строка[] = [];
        rowKeys.push({ rowKey, indicatorKey: assignedIndicatorKey });
        для (let l = 0, len1 = this.rows.length; l < len1; l++) {
            const rowAttr = this.rows[l];
            if (rowAttr в record) {
                this.rowsHasValue[l] = true;
                **rowKey.push(record[rowAttr]);**
            }
        }
        
        const colKey: строка[] = [];
        colKeys.push({ colKey, indicatorKey: assignedIndicatorKey });
        для (let n = 0, len2 = this.columns.length; n < len2; n++) {
            const colAttr = this.columns[n];
            if (colAttr в record) {
                this.columnsHasValue[n] = true;
                **colKey.push(record[colAttr]);**
            }
        }
        
        для (let row_i = 0; row_i < rowKeys.length; row_i++) {
            const rowKey = rowKeys[row_i].rowKey;
            ...
            
            для (let col_j = 0; col_j < colKeys.length; col_j++) {
                const colKey = colKeys[col_j].colKey;
                
                // 生成 flatRowKey，将用于维度tree对象的key
                **const flatRowKey = rowKey.join(this.stringJoinChar);**
**                const flatColKey = colKey.join(this.stringJoinChar);**
                
                ...
                
                if (rowKey.length !== 0) {
                  if (!this.rowFlatKeys[flatRowKey]) {
                    **this.rowKeys.push(rowKey);**
                    this.rowFlatKeys[flatRowKey] = 1;
                  }
                }
                if (colKey.length !== 0) {
                  if (!this.colFlatKeys[flatColKey]) {
                    **this.colKeys.push(colKey);**
                    this.colFlatKeys[flatColKey] = 1;
                  }
                }
        
                if (!this.tree[flatRowKey]) {
                  this.tree[flatRowKey] = {};
                }
                
                // 生成维度 tree 对象
                if (!this.tree[flatRowKey]?.[flatColKey]) {
                  this.tree[flatRowKey][flatColKey] = [];
                }
                
                const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedполеDependIndicatorKeys;
                для (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                    let needAddToAggregator = false;
                    
                    ...
                    
                    // 生成维度 tree 对象
                    if (needAddToAggregator) {
                        **this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);**
                    }
                }
                ...
                
            }
        }
        
    }
}    

```


#### Assemble к generate `rowTree`, `columnTree`

* `ArrToTree` и `ArrToTree1`: Convert `rowKeys` и `colKeys` к a tree structure    

```xml
private ArrToTree1(
    arr: строка[][],
    rows: строка[],
    indicators: (строка | IIndicator)[] | undefined,
    ...
  ): {
     {
       значение: строка; 
       dimensionKey: строка;
       children: любой[] | undefined
     } 
  }[] {
    const result: любой[] = []; // 结果
    const concatStr = this.stringJoinChar; // 连接符(随便写，保证key唯一性就хорошо)
    const map = новый Map(); // 存储根节点 主要提升性能
    
    функция addсписок(список: любой, isGrandTotal: логический) {
      const path: любой[] = []; // 路径
      let node: любой; // 当前节点
      список.forEach((значение: любой, index: число) => {
        path.push(значение);
        const flatKey = path.join(concatStr);
        //id的值可以每次生成一个新的 这里用的path作为id 方便макет对象获取
        let item: { значение: строка; dimensionKey: строка; children: любой[] | undefined } = map.get(flatKey); // 当前节点
        if (!item) {
          item = {
            значение,
            dimensionKey: rows[index],
            //树的叶子节点补充指标
            children:
              index === список.length - 1 && (indicators?.length ?? 0) >= 1
                ? indicators?.map(indicator => {
                    if (typeof indicator === 'строка') {
                      возврат {
                        indicatorKey: indicator,
                        значение: indicator
                      };
                    }
                    возврат {
                      indicatorKey: indicator.indicatorKey,
                      значение: indicator.title
                    };
                  })
                : []
          };

          map.set(flatKey, item); // 存储路径对应的节点
          if (node) {
            node.children.push(item);
          } else {
            if (showGrandTotalsOnTop && isGrandTotal) {
              result.unshift(item);
            } else {
              result.push(item);
            }
          }
        }
        node = item; // 更新当前节点
      });
    }

    arr.forEach(item => addсписок(item, false));
    ...
    
    возврат result;
}    

```


#### Search


`сводныйтаблица` can obtain cell values от the `данныеset` module through методы like `сводныйтаблица.getCellValue`. These методы will событиеually call the `данныеset.getAggregator` method.

It can be seen that it is directly read through `flatRowKey + flatColKey + indicatorIndex` на the `dimension tree объект`, which is very convenient, и the time complexity can almost be regarded as `O(1)`

```xml
getAggregator(
    rowKey: строка[] | строка = [],
    colKey: строка[] | строка = [],
    indicator: строка,
    considerChangedValue: логический = true,
    indicatorPosition?: { позиция: 'col' | 'row'; index?: число }
  ): IAggregator {
    const indicatorIndex = this.indicatorKeys.indexOf(indicator);

    ...
    
    const agg = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];
    
    возврат agg
}    

```


#### данные Update Status


*  Add: в a tree display scenario, if you need к dynamically insert child node данные, you may use the `setTreeNodeChildren` интерфейс -> call the `addRecords` интерфейс -> trigger `processRecord`     

*  Change: в the таблица editing scenario, the значение из the cell may be updated, и `сводныйтаблица.changeCellValues` и `сводныйтаблица.changeCellValue` will be called к change the cell данные    

* в addition к triggering the recalculation из ширина и высота, the above method will ultimately trigger the `данныеset.changeRecordполеValue` method (as shown в the код below) during данные processing. It can be seen that `records` will be updated первый; then `this.processRecords()` is called к начало traversing `records` again, regenerating the `dimension tree объект`.

```xml
changeRecordполеValue(полеимя: строка, oldValue: строка | число, значение: строка | число) {
  ...
  
  для (let i = 0, len = this.records.length; i < len; i++) {
      const record = this.records[i];
      if (record[полеимя] === oldValue) {
        **record[полеимя] = значение;**
      }
  }
  
  this.rowFlatKeys = {};
  this.colFlatKeys = {};
  this.tree = {};
  **this.processRecords();**
}    

```


## данные Analysis


### фон из the Requirement

One из the core functions из multidimensional таблицаs is данные analysis, which can help users analyze various scenario indicators и comparisons, aiding business analysis к drive decision-making. Следующий are the данные analysis capabilities из сводныйтаблица.

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Rp8Qw9RGShJluZbjQkwcj3linIh.gif)



### Requirements Analysis


1. в the предыдущий section "автоmatic Organization из Dimension Tree", we imagined the `dimension tree объект` значение as the `IndicatorValue[]` тип. к implement the functions из aggregation и calculated полеs, the данные structure из the `dimension tree объект` значение needs к be redesigned. **What should the данные structure be? How can we perform statistics на these aggregated данные while traversing **`**Records**`**? Этоctually one из the core designs из this section.**    

```Typescript
// 我们之前设想据维度 tree 对象
const tree = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: "origin_price",
                значение: '4299'       
            }
            {
                indicatorKey: "curr_price",
                значение: '3999'       
            }
        ]
    }
}    

```
1. The filtering и derived поле functions can be implemented before traversing `Records`. According к the agreed filtering rules, unnecessary данные is removed от `Records` первый, без affecting subsequent calculations.


<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">What is the difference between calculated полеs и derived полеs? Both are данные derived от the original данные.    
Derived полеs: **Dimensions** derived от the original данные. eg. There is a dimension date поле с the значение "2025-02-03", и it is expected к derive dimensions year, month, week, day    
Calculated полеs: **Metrics** derived от the original данные. eg. There are metrics "original price" и "actual price", и it is expected к derive the metric "discount strength"    

</div>
1. Summarization is a commonly used feature в multidimensional таблицаs. It may be implemented **after traversing** `**Records**`, because we need к aggregate и calculate полеs after they have values, only then can we perform summarization.    



According к the above analysis, в order к achieve данные analysis функциональность, the данные parsing process may change as follows:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/FZ6SbAhVHoOGaSx5A54c9BO0n3e.gif' alt='' ширина='1000' высота='авто'>



### Source код & Implementation

с the above analysis и questions, let's take a loхорошо в how the source код is implemented.    

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">код entry: `packвозрастs/vтаблица/src/данныеset/данныеset.ts`    
Следующий код has been simplified    
</div>


These logics are mainly distributed в the `setRecords`, `processRecords`, и `processRecord` методы.

*  setRecords: Entry method для данные processing    \r

* processRecords: Process данные, iterate through все entries    

* processRecord: Process a single данные entry    



#### Filter


The source код is as follows, it should be understandable    

```xml
export class данныеset {
    // 过滤规则
    filterRules?: FilterRules;
    
    // 明细数据
    records?: любой[] | Record<строка, любой[]>;
    filteredRecords?: любой[] | Record<строка, любой[]>;
    
    // 处理数据, 遍历所有条目
    private processRecords() {
        let isNeedFilter = false;
        if ((this.filterRules?.length ?? 0) >= 1) {
          isNeedFilter = true;
        }
        
        для (let i = 0, len = this.records.length; i < len; i++) {
            const record = this.records[i];
            // 如果 this.filterRecord(record) 为false，这条原始数据就被过滤掉了，不进入后面的数据处理流程
            if (!isNeedFilter || **this.filterRecord(record)**) {
                (this.filteredRecords as любой[]).push(record);
                this.processRecord(record);
            }
          }
    }
    
    // 遍历过滤规则，有一条命中就会被过滤掉
    private filterRecord(record: любой): логический {
        let isReserved = true;
        if (this.filterRules) {
            для (let i = 0; i < this.filterRules.length; i++) {
                const filterRule = this.filterRules[i];
                if (filterRule.filterKey) {
                    const filterValue = record[filterRule.filterKey];
                    if (filterRule.filteredValues?.indexOf(filterValue) === -1) {
                        isReserved = false;
                        break;
                    }
                } else if (!filterRule.filterFunc?.(record)) {
                    isReserved = false;
                    break;
                }
            }
        }
        возврат isReserved;
    }
}    

```


#### Derived полеs


```xml
export class данныеset {
    // 派生字段规则
    derivedполеRules?: DerivedполеRules;
    
    // 处理单条数据
    private processRecord(record: любой, assignedIndicatorKey?: строка) {
        this.derivedполеRules?.forEach((derivedполеRule: DerivedполеRule, i: число) => {
            if (derivedполеRule.полеимя && derivedполеRule.derivedFunc) {
                // 根据派生字段规则的 полеимя 和 函数，生成字段数据，写入 record 中
                record[derivedполеRule.полеимя] = derivedполеRule.derivedFunc(record);
            }
        });
    
    }
}    

```


#### Aggregation


##### Aggregator Class


1. Implement respective `aggregation classes` based на the `Aggregator class` according к different `AggregationType`.

```xml
export enum AggregationType {
  RECORD = 'RECORD',
  никто = 'никто', //不做聚合 只获取其中一条数据作为节点的record 取其поле
  SUM = 'SUM',
  MIN = 'MIN',
  MAX = 'MAX',
  AVG = 'AVG',
  COUNT = 'COUNT',
  пользовательский = 'пользовательский',
  RECALCULATE = 'RECALCULATE' // 计算字段
}

// packвозрастs/vтаблица/src/ts-types/данныеset/aggregation.ts
export интерфейс IAggregator {
  records: любой[];  // 缓存聚合值的records集合，为后续跟踪提供数据依据
  значение: () => любой; // 获取聚合值
  push: (record: любой) => void; // 将数据记录添加到聚合器中，用于计算聚合值
  deleteRecord: (record: любой) => void; // 从聚合器中删除记录，并更新聚合值。eg. 调用vтаблица的删除接口deleteRecords会调用该接口
  updateRecord: (oldRecord: любой, newRecord: любой) => void; // 更新数据记录，并更新聚合值。eg. 调用接口updateRecords会调用该接口
  recalculate: () => любой; // 重新计算聚合值。eg. 目前复制粘贴单元格值会调用该方法。
  formatValue?: (col?: число, row?: число, таблица?: Baseтаблицаапи) => любой; // 格式化后的聚合值
  formatFun?: () => любой; // 格式化函数
  clearCacheValue: () => любой; // 清空缓存值
  reset: () => void; // 重置聚合器
}

export abstract class Aggregator implements IAggregator {
  isAggregator?: логический = true;
  isRecord?: логический = true; //是否需要维护records 将数据源都记录下来
  records: любой[] = [];
  тип?: строка;
  key: строка;
  поле?: строка | строка[];
  formatFun?: любой;
  _formatedValue?: любой;

  constructor(config: { key: строка; поле: строка | строка[]; formatFun?: любой; isRecord?: логический }) {
    this.key = config.key;
    this.поле = config.поле;
    this.formatFun = config.formatFun;
    this.isRecord = config.isRecord ?? this.isRecord;
  }
  abstract push(record: любой): void;
  abstract deleteRecord(record: любой): void;
  abstract updateRecord(oldRecord: любой, newRecord: любой): void;
  abstract значение(): любой;
  abstract recalculate(): любой;
  clearCacheValue() {
    this._formatedValue = undefined;
  }
  formatValue(col?: число, row?: число, таблица?: Baseтаблицаапи) {
     ...
  }
  reset() {
    this.records = [];
    this.clearCacheValue();
  }
}

// 基于 Aggregator 实现各自的聚合类
export class SumAggregator extends Aggregator {
    ...
}
export class CountAggregator extends Aggregator {
    ...
}
...    

```
1. The значение из `维度tree对象` is actually `Aggregator[]`    

```xml
tree: Record<строка, Record<строка, Aggregator[]>> = {};    

```


We choose `AggregationType.SUM` и `AggregationType.RECALCULATE` (calculated полеs) к specifically analyze the implementation process.




##### SumAggregator

The general process is as follows:    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/L2n5wNjt4hQaZSbFmkAcAzIFn1e.gif)



```xml
// packвозрастs/vтаблица/src/ts-types/данныеset/aggregation.ts
export const регистрацияedAggregators: {
  [key: строка]: {
    новый (args: {
      key?: строка;
      поле: строка | строка[];
      aggregationFun?: любой;
      formatFun?: любой;
      isRecord?: логический;
      needSplitPositiveAndNegative?: логический;
      calculateFun?: любой;
      dependAggregators?: любой;
      dependIndicatorKeys?: строка[];
    }): Aggregator;
  };
} = {};

// packвозрастs/vтаблица/src/данныеset/данныеset.ts
export class данныеset {
    // 聚合规则
    aggregationRules?: AggregationRules;
    
     // 将聚合类型注册收集到 регистрацияedAggregators 对象，方便后面调用
    регистрацияAggregator(тип: строка, aggregator: любой) {
        регистрацияedAggregators[тип] = aggregator;
    }
    
    // 将聚合类型注册。 在 constructor 一开始就会执行
    регистрацияAggregators() {
        this.регистрацияAggregator(AggregationType.RECORD, RecordAggregator);
        this.регистрацияAggregator(AggregationType.SUM, SumAggregator);
        this.регистрацияAggregator(AggregationType.COUNT, CountAggregator);
        this.регистрацияAggregator(AggregationType.MAX, MaxAggregator);
        this.регистрацияAggregator(AggregationType.MIN, MinAggregator);
        this.регистрацияAggregator(AggregationType.AVG, AvgAggregator);
        this.регистрацияAggregator(AggregationType.никто, NoneAggregator);
        this.регистрацияAggregator(AggregationType.RECALCULATE, RecalculateAggregator);
        this.регистрацияAggregator(AggregationType.пользовательский, пользовательскийAggregator);
    }
    
     
    // 处理单条数据
    private processRecord(record: любой, assignedIndicatorKey?: строка) {
        ...
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedполеDependIndicatorKeys;
        для (let i = 0; i < toComputeIndicatorKeys.length; i++) {
            
            ...
            // aggRule 有可能为空，具体看是什么指标字段
            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
            let needAddToAggregator = false;
            
            ...
            
            // 如果这个 indicatorKey 在 record 中，就会触发下面的逻辑
            toComputeIndicatorKeys[i] в record && (needAddToAggregator = true);
            if (!this.tree[flatRowKey]?.[flatColKey]?.[i] && needAddToAggregator) {
                // 若这个 indicatorKey 没指定 aggRule，就默认是 AggregationType.SUM
                // 往维度tree对象的值中添加 Aggregator 实例
                this.tree[flatRowKey][flatColKey][i] = новый регистрацияedAggregators[
                    **aggRule?.aggregationType ?? AggregationType.SUM**
                ]({
                    key: toComputeIndicatorKeys[i],
                    поле: aggRule?.поле ?? toComputeIndicatorKeys[i],
                    aggregationFun: aggRule?.aggregationFun,
                    formatFun:
                        aggRule?.formatFun ??
                        (
                          this.indicators?.find((indicator: строка | IIndicator) => {
                              if (typeof indicator !== 'строка') {
                                  возврат indicator.indicatorKey === toComputeIndicatorKeys[i];
                              }
                              возврат false;
                          }) as IIndicator
                        )?.format
              });
            }
            
            if (needAddToAggregator) {
                // 并调用 Aggregator 实例的 push 方法，往 Aggregator.records 中存原始数据
                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
            }
        }
    }
}

// packвозрастs/vтаблица/src/ts-types/данныеset/aggregation.ts
export class SumAggregator extends Aggregator {
    тип: строка = AggregationType.SUM;
    sum = 0;
    ...
    
    push(record: любой): void {
        if (record) {
            if (this.isRecord && this.records) {
                if (record.isAggregator) {
                    this.records.push(...record.records);
                } else {
                    this.records.push(record);
            }
        }
        
        ...
        const значение = parseFloat(record[this.поле]);
        this.sum += значение;
        if (this.needSplitPositiveAndNegativeForSum) {
          if (значение > 0) {
            this.positiveSum += значение;
          } else if (значение < 0) {
            this.nвозрастtiveSum += значение;
          }
        }
    
        this.clearCacheValue();
    }
    
    // 获取 sum 值
    значение() {
        возврат this.records?.length >= 1 ? this.sum : undefined;
    }
  
  ...
}    

```


##### Calculated полеs


The `Aggregator class` для calculating полеs is `RecalculateAggregator`. The processing flow is also very similar к the flow из `SumAggregator`.

```Typescript
export class данныеset {
    // 计算字段规则
    calculatedполеRules?: CalculateddполеRules;
    /** 计算字段 */
    calculatedFiledKeys?: строка[];
    calculatedполеDependIndicatorKeys?: строка[];
    
    // 处理单条数据
    private processRecord(record: любой, assignedIndicatorKey?: строка) {
        ...
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedполеDependIndicatorKeys;
        для (let i = 0; i < toComputeIndicatorKeys.length; i++) {
            // 遍历计算字段key
            if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                // 找到计算字段对应的计算规则
                const calculatedполеRule = this.calculatedполеRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                
                if (!this.tree[flatRowKey]?.[flatColKey]?.[i]) {
                    // 往 维度tree 添加新 RECALCULATE Aggregator 实例
                    this.tree[flatRowKey][flatColKey][i] = новый регистрацияedAggregators[AggregationType.RECALCULATE]({
                    key: toComputeIndicatorKeys[i],
                    поле: toComputeIndicatorKeys[i],
                    isRecord: true,
                    formatFun: (
                      this.indicators?.find((indicator: строка | IIndicator) => {
                        if (typeof indicator !== 'строка') {
                          возврат indicator.indicatorKey === toComputeIndicatorKeys[i];
                        }
                        возврат false;
                      }) as IIndicator
                    )?.format,
                    calculateFun: calculatedполеRule?.calculateFun,
                    dependAggregators: this.tree[flatRowKey][flatColKey],
                    dependIndicatorKeys: calculatedполеRule?.dependIndicatorKeys
                  });
                }
                
                // 将依赖的原始数据 record 存进 RECALCULATE Aggregator.records 中
                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
            }
        }
    }
}

// packвозрастs/vтаблица/src/ts-types/данныеset/aggregation.ts
export class RecalculateAggregator extends Aggregator {
    тип: строка = AggregationType.RECALCULATE;
    isRecord?: логический = true;
    declare поле?: строка;
    calculateFun: функция;
    полеValue?: любой;
    dependAggregators: Aggregator[];
    dependIndicatorKeys: строка[];
    
    ...
    
    push(record: любой): void {
        if (record && this.isRecord && this.records) {
            if (record.isAggregator) {
                this.records.push(...record.records);
            } else {
                this.records.push(record);
            }
        }
        this.clearCacheValue();
    }
    
    // 获取计算字段的值
    значение() {
        if (!this.полеValue) {
            // 获取依赖的 Aggregator 的值
            const aggregatorValue = _getDependAggregatorValues(this.dependAggregators, this.dependIndicatorKeys);
            // 再用 calculateFun 算出计算字段的值
            this.полеValue = this.calculateFun?.(aggregatorValue, this.records, this.поле);
        }
        возврат this.полеValue;
    }
}    

```


#### Summary


This process is quite troublesome ...    \r

```Typescript
export class данныеset {
    // 汇总配置
    totals?: Totals;
    // 全局统计各指标的极值
    indicatorStatistics: { max: Aggregator; min: Aggregator; total: Aggregator }[] = [];
    // 缓存rows对应每个值是否为汇总字段
    private rowsIsTotal: логический[] = [];
    private colsIsTotal: логический[] = [];
    private colGrandTotalLabel: строка;
    private colSubTotalLabel: строка;
    private rowGrandTotalLabel: строка;
    private rowSubTotalLabel: строка;
    // 记录用户传入的汇总数据
    totalRecordsTree: Record<строка, Record<строка, Aggregator[]>> = {};
    
    setRecords(records: любой[] | Record<строка, любой[]>) {
        ...
        // 处理汇总. 在 this.processRecords() 之后；在排序之前
        this.totalStatistics();
    }
    
    
    // 汇总小计
    totalStatistics() {
        // 如果 row 或 column有汇总配置
        if (...) {
            const rowTotalKeys: строка[] = [];
            
            // 遍历维度 tree 中的每个行维度、列维度
            объект.keys(that.tree).forEach(flatRowKey => {
                const rowKey = flatRowKey.split(this.stringJoinChar);
                объект.keys(that.tree[flatRowKey]).forEach(flatColKey => {
                    // 如果 row 有小计
                    if (...) {
                        для (let i = 0, len = that.totals?.row?.subTotalsDimensions?.length; i < len; i++) {
                            // 取有小计配置的 row 维度
                            const dimension = that.totals.row.subTotalsDimensions[i];
                            const dimensionIndex = that.rows.indexOf(dimension);
                            
                            const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
                            if (this.rowHierarchyType !== 'tree') {
                                // 如果是tree的情况则不追加小计单元格值
                                rowTotalKey.push(that.rowSubTotalLabel);
                            }
                            
                            if (!this.tree[flatRowTotalKey]) {
                                this.tree[flatRowTotalKey] = {};
                                rowTotalKeys.push(flatRowTotalKey);
                            }
                            if (!this.tree[flatRowTotalKey][flatColKey]) {
                                this.tree[flatRowTotalKey][flatColKey] = [];
                            }
                            
                            // 和之前处理聚合的逻辑类似
                            // 会往维度tree该行列维度中添加 Aggreator 实例
                            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedполеDependIndicatorKeys;
                            для (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                                if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                    if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                    
                                        ...
                                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                        this.tree[flatRowTotalKey][flatColKey][i] = новый регистрацияedAggregators[
                                            aggRule?.aggregationType ?? AggregationType.SUM
                                        ]({
                                            key: toComputeIndicatorKeys[i],
                                            поле: aggRule?.поле ?? toComputeIndicatorKeys[i],
                                            formatFun:
                                              aggRule?.formatFun ??
                                              (
                                                this.indicators?.find((indicator: строка | IIndicator) => {
                                                  if (typeof indicator !== 'строка') {
                                                    возврат indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                  }
                                                  возврат false;
                                                }) as IIndicator
                                              )?.format
                                        });
                                    }
                                 }
                                 // 这一步有点意思，会往维度tree中 flatRowTotalKey 维度的 aggreator 添加所有flatRowKey下的 aggreator
                                 if (flatRowTotalKey !== flatRowKey) {
                                    this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                 }
                            }
                        }
                    }
                    
                    // 如果 row 有总计配置, 也做类似的处理
                    if (that.totals?.row?.showGrandTotals || this.columns.length === 0) {
                        ...
                    }
                    
                    colCompute(flatRowKey, flatColKey);
                })
                
                // 增加出来的rowTotalKeys 再遍历一次 汇总小计的小计 如 东北小计（row）-办公用品小计（col）所指单元格的值
                rowTotalKeys.forEach(flatRowKey => {
                    объект.keys(that.tree[flatRowKey]).forEach(flatColKey => {
                        // 计算每一行的所有列的汇总值
                        colCompute(flatRowKey, flatColKey);
                    })
                })
                
            })
            
            для (const flatRowKey в that.totalRecordsTree) {
                для (const flatColKey в that.totalRecordsTree[flatRowKey]) {
                    // 计算每一行的所有列的汇总值
                    colCompute(flatRowKey, flatColKey);
                }
            }
        }
    }
}      

```


#### сортировкаing


сортировка `colKeys` и `rowKeys` respectively    

```xml
export class данныеset {
    // 排序规则
    сортировкаRules?: сортировкаRules;
    
    colKeys: строка[][] = [];
    rowKeys: строка[][] = [];
    // 存储下未排序即初始normal下rowKeys和colKeys
    colKeys_normal: строка[][] = [];
    rowKeys_normal: строка[][] = [];
    
    setRecords(records: любой[] | Record<строка, любой[]>) {
        this.processRecords(); // 这里收集了维度成员
        
        ...
        this.rowKeys_normal = this.rowKeys.slice();
        this.colKeys_normal = this.colKeys.slice();
        
        this.сортировкаKeys();
    }
    
    // 根据排序规则 对维度keys排序
    сортировкаKeys() {
        this.colKeys = this.colKeys_normal.slice();
        this.rowKeys = this.rowKeys_normal.slice();
        if (!this.сортировкаed) {
            this.сортировкаed = true;
            
            // 排序
            this.rowKeys.сортировка(this.arrсортировка(this.rows, true));
            const сортировкаfun = this.arrсортировка(this.columns, false);
            this.colKeys.сортировка(сортировкаfun);
        }
    }
    
    // 综合配置的多条排序规则，生成生成排序函数
    arrсортировка(полеArr: строка[], isRow: логический) {
        ...
    }
}    

```


## данные Parsing Process Final Version


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GWOrb4obUouyp9xjsmdcfLUVn0f.gif' alt='' ширина='1000' высота='авто'>

The core is the design из the `dimension tree объект` и the `Aggregator class`    



## Related Materials


*  

*  

*  [透视数据分析 - 官方文档](https://visactor.io/vтаблица/guide/данные_analysis/сводный_таблица_данныеAnalysis)    

*  [observablehq](https://observablehq.com/@rigel/appendix#transform_таблицаs_rearrange)     









# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)