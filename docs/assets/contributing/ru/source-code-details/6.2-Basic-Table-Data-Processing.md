---
заголовок: 6.2 базовый таблица данные Processing    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Introduction


для все таблицаs, данные sources are an essential part. `@Visactor/Vтаблица` provides various данные source structures, including two-dimensional arrays, объект structures, tree structures, и asynchronous lazy-загружен данные sources (https://visactor.com/vтаблица/guide/данные/async_данные). к adapt к so many данные structures, a reasonable данные processing module is needed, и `@Visactor/Vтаблица` provides such capability internally. Let's see how базовый таблицаs parse данные.

## Core Classes Involved в таблица данные Processing

*  Vтаблица\\packвозрастs\\vтаблица\\src\\данные\\CachedданныеSource.ts: `CachedданныеSource` is responsible для intercepting incoming external records и provides апиs для adding, deleting, updating, и querying records; it wraps the `данныеSource` с an additional layer.    

*  Vтаблица\\packвозрастs\\vтаблица\\src\\данные\\данныеSource.ts: This class implements various данные processing operations и maintains the raw данные в `данныеSource.records` к support dynamic updates из the таблица, as well as the underlying implementation logic из the CRUD апи provided externally по the базовый таблица instance. `Baseтаблица` will intercept modifications к the instance из данныеSource к ensure that the базовый таблица is re-rendered when данныеSource is modified.    

## списоктаблица данные Parsing Principle

The предыдущий article introduced the initialization process из `списоктаблица` [], which briefly mentioned the part related к records. Now, let's delve into the analysis из the данные source parsing process из `списоктаблица`.    

We will analyze с a simple case. Следующий код generates a базовый таблица (since the process из parsing данные involves сортировкаing, сортировкаState is added в the configuration к facilitate analyzing how сортировкаState affects данные parsing).

```javascript
import * as Vтаблица от '../../src';
const CONTAINER_ID = 'vтаблица';
const generatePersons = count => {
  возврат массив.от(новый массив(count)).map((_, i) => ({
    id: i + 1,
    email1: `${i + 1}@xxx.com`,
  }));
};

export функция createтаблица() {
  const records = generatePersons(2000);
  const columns: Vтаблица.ColumnsDefine = [
    {
      поле: 'id',
      заголовок: 'ID',
      сортировка: true,
    },
    {
      поле: 'email1',
      заголовок: 'email',
      сортировка: true,
    },
  ];
  const опция: Vтаблица.списоктаблицаConstructorOptions = {
    container: document.getElementById(CONTAINER_ID),
    records,
    columns,
    ширинаMode: 'автоширина',
    сортировкаState: {
      поле: 'email1',
      порядок: 'desc'
    },
  };
  const таблицаInstance = новый Vтаблица.списоктаблица(document.getElementById(CONTAINER_ID)!, option);
}
    

```
The initialization process has already been introduced в [], so the remaining processes will не be elaborated на. We will directly move на к the parts related к records.    \r

*  packвозрастs\vтаблица\src\списоктаблица.ts    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/TAt5bFhRfo9UPRxh61Wc4zKGnRc.gif' alt='' ширина='1000' высота='авто'>

Here are three judgments made, two из which can be classified as one. Let's первый loхорошо в the judgments из Следующий two branches.

### ввод records 

#### setRecords

```javascript
  // packвозрастs\vтаблица\src\списоктаблица.ts
  */***
*   * 设置表格数据 及排序状态*
*   * @param records*
*   * @param option 附近参数，其中的сортировкаState为排序状态，如果设置null 将清除目前的排序状态*
*   */*
  setRecords(records: массив<любой>, option?: { сортировкаState?: сортировкаState | сортировкаState[] | null }): void {
    // 省略
    this.internalProps.данныеSource = null;
    // 省略
    
    *// 清空单元格内容*
    this.scenegraph.clearCells();

    *//重复逻辑抽取updateширинавысота*
    if (сортировка !== undefined) {
      if (сортировка === null || (!массив.isArray(сортировка) && isValid(сортировка.поле)) || массив.isArray(сортировка)) {
        this.internalProps.сортировкаState = this.internalProps.multipleсортировка ? (массив.isArray(сортировка) ? сортировка : [сортировка]) : сортировка;
        this.stateManвозрастr.setсортировкаState((this as любой).сортировкаState as сортировкаState);
      }
    }
    
    if (records) {
      _setRecords(this, records);
      if ((this as любой).сортировкаState) {
        const сортировкаState = массив.isArray((this as любой).сортировкаState) ? (this as любой).сортировкаState : [(this as любой).сортировкаState];

        *// 根据сортировка规则进行排序*
        if (сортировкаState.некоторые((item: любой) => item.order && item.поле && item.order !== 'normal')) {
          if (this.internalProps.макетMap.headerObjectsIncludeHided.некоторые(item => item.define.сортировка !== false)) {
            this.данныеSource.сортировка(
              сортировкаState.map((item: любой) => {
                const сортировкаFunc = this._getсортировкаFuncFromHeaderOption(undefined, item.поле);
                *// 如果сортировка传入的信息不能生成正确的сортировкаFunc，直接更新表格，避免首次加载无法正常显示内容*
                const hd = this.internalProps.макетMap.headerObjectsIncludeHided.find(
                  (col: любой) => col && col.поле === item.поле
                );
                возврат {
                  поле: item.поле,
                  порядок: item.order || 'asc',
                  orderFn: сортировкаFunc ?? defaultOrderFn
                };
              })
            );
          }
        }
      }
      this.refreshRowColCount();
    } else {
      _setRecords(this, records);
    }
    
    *// 生成单元格场景树*
    this.scenegraph.createSceneGraph();
    //... 省略
    this.render();

  }    

```
1. первый, clear the original данныеSource, compatible с the предыдущий сортировка configuration, и then clear все cell contents;    \r

1. следующий, update the internal this.сортировка through the stateManвозрастr.setсортировкаState method к obtain the базовый information из the cell corresponding к сортировка. в setсортировкаState, the сортировка configuration is generated based на the passed сортировкаState configuration и column information.    

1. Enter the следующий branch и check if records exist. Both checks will enter _setRecords, и the only difference between the two checks is that if records are passed в, initial сортировкаing will be performed based на the сортировкаState и the сортировка configuration на the column. \r

#### _setRecords

```javascript
// packвозрастs\vтаблица\src\core\таблицаHelper.ts
*// 先卸载 данныеSource 上监听的所有事件，然后执行 fn，最后重新监听 данныеSource 上的事件*
export функция _dealWithUpdateданныеSource(таблица: Baseтаблицаапи, fn: (таблица: Baseтаблицаапи) => void): void {
  const { данныеSourceсобытиеIds } = таблица.internalProps;

  if (данныеSourceсобытиеIds) {
    данныеSourceсобытиеIds.forEach((id: любой) => таблица.internalProps.handler.off(id));
  }

  fn(таблица);

  таблица.internalProps.данныеSourceсобытиеIds = [
    таблица.internalProps.handler.на(таблица.internalProps.данныеSource, данныеSource.событие_TYPE.CHANGE_ORDER, () => {
      if (таблица.данныеSource.hierarchyExpandLevel) {
        таблица.refreshRowColCount();
      }
      таблица.render();
    })
  ];
}

*/** @private */*
export функция _setRecords(таблица: списоктаблицаапи, records: любой[] = []): void {
  _dealWithUpdateданныеSource(таблица, () => {
    таблица.internalProps.records = records;
    const newданныеSource = (таблица.internalProps.данныеSource = CachedданныеSource.ofArray(
      records,
      таблица.internalProps.данныеConfig,
      таблица.pagination,
      таблица.internalProps.columns,
      таблица.internalProps.макетMap.rowHierarchyType,
      getHierarchyExpandLevel(таблица)
    ));
    // 添加到 Релизсписок 中
    таблица.addРелизObj(newданныеSource);
  });
}    

```
_setRecords calls _dealWithUpdateданныеSource, passing в a обратный вызов функция;    \r

в _dealWithUpdateданныеSource, the первый step is к remove все событие списокeners related к данныеSource, the second step is к execute the passed обратный вызов функция, и the third step is к bind the CHANGE_ORDER событие к the данныеSource. When the CHANGE_ORDER событие is triggered, the таблица will be re-rendered.    \r

Returning к the passed-в обратный вызов функция, it первый updates the records в internalProps, saving the original records passed в externally. Then it calls the CachedданныеSource.ofArray method к obtain an instance из CachedданныеSource, which is assigned к таблица.internalProps.данныеSource;    \r

Before parsing данные в ofArray, getHierarchyExpandLevel is called к get the текущий tree structure's развернуть level, и it is passed as the последний параметр к ofArray.    \r

After _setRecords is completed, this.scenegraph.createSceneGraph() и this.render() are called к trigger таблица rendering.    

### Pass в данныеSource 

Since Baseтаблица implements the proxy для данныеSource, when данныеSource is passed в, it will directly follow the set данныеSource process.

```xml
// packвозрастs\vтаблица\src\списоктаблица.ts
  set данныеSource(данныеSource: CachedданныеSource | данныеSource) {
    *// 清空单元格内容*
    this.scenegraph.clearCells();
    _setданныеSource(this, данныеSource);
    this.refreshRowColCount();
    *// 生成单元格场景树*
    this.scenegraph.createSceneGraph();
    this.render();
  }    

```
#### _setданныеSource

Compared к the _setRecords method that only receives records, when данныеSource is passed в, Vтаблица internally calls _setданныеSource. Следующий diagram shows the process из _setданныеSource.    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/DYqRw3L4ohZPjibEpIkcL79Jnif.gif)

After completing the initialization из данныеSource, just like the latter part из the process из passing в records, set данныеSource calls this.render() к trigger таблица rendering. This completes the данные parsing из списоктаблица, where данныеSource is mainly used для the parsing из the body в the базовый таблица.

### CachedданныеSource Preprocessing


Summarizing the general данные processing flow, we can get Следующий flowграфик:    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Xosww5POdhCOgMbCsCbcWk0vnlc.gif)

в summary, whether passing в данныеSource или records, it inevitably involves CachedданныеSource. Below is a detailed explanation из CachedданныеSource.    \r

### CachedданныеSource Core Processing


The previously mentioned situation из passing в records refers к the CachedданныеSource.ofArray method. по observing the ofArray method, it is found that it essentially still uses новый CachedданныеSource, but adapts the records. The первый параметр из the ofArray method is options.records.    \r

Note that one из the parameters из CachedданныеSource is passed с records. The reason для passing records will be explained later.    

```xml
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
  static ofArray(
    массив: любой[],
    данныеConfig?: IсписоктаблицаданныеConfig,
    pagination?: IPagination,
    columns?: ColumnsDefine,
    rowHierarchyType?: 'grid' | 'tree',
    hierarchyExpandLevel?: число
  ): CachedданныеSource {
    возврат новый CachedданныеSource(
      {
        get: (index: число): любой => {
          *// if (массив.isArray(index)) {*
          *//   возврат getValueFromDeepArray(массив, index);*
          *// }*
          возврат массив[index];
        },
        length: массив.length,
        records: массив
      },
      данныеConfig,
      pagination,
      columns,
      rowHierarchyType,
      hierarchyExpandLevel
    );
  }    

```
Observing the constructor из CacheданныеSource, it can be found that CachedданныеSource inherits от данныеSource. When initializing CachedданныеSource, the _isGrouped поле is updated based на groupByRules, which will affect the call к getCellValue. After completing некоторые базовый operations, данныеSource is directly initialized.    \r

```javascript
// packвозрастs\vтаблица\src\данные\CachedданныеSource.ts
export class CachedданныеSource extends данныеSource {
 /// ....
  constructor(
    opt?: данныеSourceParam,
    данныеConfig?: IсписоктаблицаданныеConfig,
    pagination?: IPagination,
    columns?: ColumnsDefine,
    rowHierarchyType?: 'grid' | 'tree',
    hierarchyExpandLevel?: число
  ) {
    let _isGrouped;
    if (isArray(данныеConfig?.groupByRules)) {
      rowHierarchyType = 'tree';
      _isGrouped = true;
    }
    super(opt, данныеConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel);
    this._isGrouped = _isGrouped;
    this._recordCache = [];
    this._полеCache = {};
  }
  // ... 
}    

```
### данныеSource Initialization


для базовый таблица данные processing, данныеSource is the most important part, including the addition, deletion, modification, и query из records, as well as the значение retrieval из the таблица body, все rely на this module.    \r

данныеSource supports six parameters during initialization    

*  данныеSourceObj: данные source объект, which can internally pass в records. As mentioned earlier в the ofArray method, records will be carried within this параметр.    \r

*  данныеConfig: данные parsing configuration    

* pagination: текущий pagination configuration    

* columns: текущий column configuration    

*  rowHierachyType: The display form из the hierarchical dimension structure, either flat или tree structure. This configuration is only used в сводный таблицаs.    \r

*  hierarchyExpandLevel: The level из expansion для the tree structure, which will affect the initialization из the tree structure в initTreeHierarchyState    \r

```javascript
// packвозрастs\vтаблица\src\данные\данныеSource.ts
export class данныеSource extends событиеTarget implements данныеSourceапи {
// ...
 constructor(
    данныеSourceObj?: данныеSourceParam,
    данныеConfig?: IсписоктаблицаданныеConfig,
    pagination?: IPagination,
    columns?: ColumnsDefine,
    rowHierarchyType?: 'grid' | 'tree',
    hierarchyExpandLevel?: число
  ) 
 //...
 }    

```
Below is the parsing process из данныеSource    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YJCcwC51Mh1xnMbLgl1chwQ3npg.gif)

### Core возможности из данныеSource


1. _source: списоктаблица stores the original records into данныеSource._source, и implements a proxy для данныеSource.records, accessing данныеSource.records is actually accessing данныеSource._source.    

1. currentIndexedданные: *каждый row corresponds к the index из the source данные*, which is a two-dimensional массив structure used к store the indices из the displayed данные, involving the базовый макет из the таблица и данные display. *Следующий пример shows currentIndexedданные в a tree structure.* The main данные processing из списоктаблица, including the generation из the tree structure, retrieval из cell content, сортировкаing, и the generation из _currentPвозрастrIndexedданные, все rely на this поле.    \r

```Typescript
[
  0, // 数据源对应第1条数据 紧邻其下的是第1条数据的子节点 说明第1条数据被展开了
  [0, 0], // 数据源对应第1条下的 第1个子节点
  [0, 1], // 数据源对应第1条下的 第2个子节点
  1, // 数据源对应第2条数据
  [1, 0], // 以此类推 。。。
  [1, 1], 
  [1, 2], 
  [1, 3], 
  2, 
  [2, 0], 
  [2, 1], 
  3
];    

```
для пример, the данныеSource.сортировка method actually сортировкаs it, but does не update the passed-в records, only updates currentIndexedданные;

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">для the use из currentIndexedданные, Вы можете refer к the данныеSource.getValueFromDeepArray method. для пример, к get the данные из the second row, the reading method is records[0].children[0], which exactly corresponds к [0,0]    
</div>
1. updatePвозрастrданные: по using the structure из the passed records и currentIndexedданные, it updates _currentPвозрастrIndexedданные (*the index из the source данные corresponding к каждый row из the текущий pвозраст*). This поле is relied upon when performing CRUD operations на the данные. After updating _currentPвозрастrIndexedданные, the initialization из the данныеSource is complete.    \r

### Analysis из Core Functional Functions Involved


Следующий diagram shows все the key functions и their roles mentioned earlier regarding the данные parsing process.    \r

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/EWvbwyuHghrBVGbeBOScTl2Unb3.gif)

## Efficient данные CRUD Operations


### Global Update и Local Update


Imagine how к efficiently update a таблица с a large число из columns без lagging. Common таблица компонент libraries based на Vue или React mostly rely на native DOM, which can utilize the built-в diff и update algorithms из VDom к achieve DOM reuse, enabling high-Производительность full данные source updates. However, `@Visactor/Vтаблица` is drawn based на canvas и does не have the concept из a virtual DOM, so achieving similar operations без affecting Производительность becomes a challenge. списоктаблица exposes many апиs для updating данные sources, including full updates и partial updates. Let's loхорошо в how optimization is done internally в списоктаблица through некоторые commonly used апиs.

### addRecords

Reviewing the списоктаблица source код, we can easily see the definition из addRecords:    \r

```javascript
// packвозрастs\vтаблица\src\списоктаблица.ts
  */***
*   * 添加数据 支持多条数据*
*   * @param records 多条数据*
*   * @param recordIndex 向数据源中要插入的位置，从0开始。不设置recordIndex的话 默认追加到最后。*
*   * 如果设置了排序规则recordIndex无效，会自动适应排序逻辑确定插入顺序。*
*   * recordIndex 可以通过接口getRecordShowIndexByCell获取*
*   */*
  addRecords(records: любой[], recordIndex?: число | число[]) {
    списоктаблицаAddRecords(records, recordIndex, this);
    this.internalProps.emptyTip?.resetVisible();
  }    

```
#### списоктаблицаAddRecords

The списоктаблицаAddRecords method is directly called в addRecords, и списоктаблица is optimized для данные updates в this функция.    \r

```Typescript
// packвозрастs\vтаблица\src\core\record-helper.ts
*/***
* * 添加数据 支持多条数据*
* * @param records 多条数据*
* * @param recordIndex 向数据源中要插入的位置，从0开始。不设置recordIndex的话 默认追加到最后。*
* * 如果设置了排序规则recordIndex无效，会自动适应排序逻辑确定插入顺序。*
* * recordIndex 可以通过接口getRecordShowIndexByCell获取*
* */*
export функция списоктаблицаAddRecords(records: любой[], recordIndex: число | число[], таблица: списоктаблица) {
  if (таблица.options.groupBy) {
    (таблица.данныеSource as CachedданныеSource).addRecordsForGroup?.(records, recordIndex);
    // 刷新行列数
    таблица.refreshRowColCount();
    // 如果有排序直接触发排序数据
    таблица.сортировкаState && сортировкаRecords(таблица);

    *// 更新整个场景树*
    таблица.scenegraph.clearCells();
    таблица.scenegraph.createSceneGraph();
  } else if ((таблица.данныеSource as CachedданныеSource).rowHierarchyType === 'tree') {
    (таблица.данныеSource as CachedданныеSource).addRecordsForTree?.(records, recordIndex);
    // 省略，与上一个分支相同
  } else if (таблица.сортировкаState) {
    таблица.данныеSource.addRecordsForсортировкаed(records);
    // 由于排序必定会打乱顺序，所有必须得重新更新场景树
    сортировкаRecords(таблица);
    *// 更新整个场景树 省略*
  } else {
    // 省略
    таблица.данныеSource.addRecords(records, recordIndex);
    const oldRowCount = таблица.transpose ? таблица.colCount : таблица.rowCount;
     // 省略
    if (таблица.scenegraph.proxy.totalActualBodyRowCount === 0) {
    *// body 单元格为 0 的情况，直接更新整个场景树*
    // 省略
      возврат;
    }
    const newRowCount = таблица.transpose ? таблица.colCount : таблица.rowCount;
    if (таблица.pagination) {
      // 省略
      if (recordIndex < endIndex) {
        *// 插入当前页或者前面的数据才需要更新 如果是插入的是当前页后面的数据不需要更新场景树*
        if (recordIndex < endIndex - perPвозрастCount) {
          *// 如果是当页之前的数据 则整个场景树都更新*
        } else {
          *// 如果是插入当前页数据*
          const rowNum = recordIndex - (endIndex - perPвозрастCount) + headerCount;
          if (oldRowCount - headerCount === таблица.pagination.perPвозрастCount) {
            *// 如果当页数据是满的 则更新插入的部分行，只计算当前页的数据*
            // updateRows 是 [{ row: xxx, col: xxx}] 的格式
            // 省略
            таблица.transpose ? таблица.scenegraph.updateCol([], [], updateRows) : таблица.scenegraph.updateRow([], [], updateRows);
          } else {
            *// 如果当页数据不是满的 则插入新数据*
            // 省略
            таблица.transpose ? таблица.scenegraph.updateCol([], addRows, []) : таблица.scenegraph.updateRow([], addRows, []);
          }
        }
      }
    } else {
      // 省略，如果没有分页的话，则需要计算出哪些需要添加，哪些需要更新，只有聚合的情况会有 updateRows
      таблица.transpose ? таблица.scenegraph.updateCol([], addRows, updateRows) : таблица.scenegraph.updateRow([], addRows, updateRows);
    }
  }
}    

```
It contains four branches internally, the первый two branches have the same logic, the only difference is whether к call данныеSource.addRecordsForGroup или данныеSource.addRecordsForTree. After the call is completed, the entire scene tree is updated directly.

The third branch checks the сортировкаState, adds данные и сортировкаs it through данныеSource.addRecordsForсортировкаed, directly updating the entire scene tree.

The most important part is the последний branch, which первый calls данныеSource.addRecords к add данные, then calculates к determine which rows и columns actually need updating, и performs partial updates through updateCol или updateRow к reduce Производительность waste.

#### возможности involved в данныеSource

* данныеSource.addRecords: Add multiple данные records в recordArr sequentially в the index позиция, while updating currentIndexedданные и pagination данные; \r

* CachedданныеSource.addRecordsForгруппа: Append таблица данные в the group;    \r

*  данныеSource.addRecordsForсортировкаed: Clear the сортировкаedIndexMap while updating records;    \r

* данныеSource.addRecordsForTree: Adjust the tree structure expansion state while updating records;    \r

#### addRecords Full Process

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/P2Quwx73bhria1b3hAEcpmynnAd.gif' alt='' ширина='820' высота='авто'>

### updateRecords

Think carefully, для данные updates, is it similar к adding данные? в некоторые cases, there is no need к update the scene tree, just like addRecords, Вы можете update specific rows directly.    \r

Similar к addRecords, updateRecords is also defined в the списоктаблица class, и it can be seen that only списоктаблицаUpdateRecords is called inside updateRecords.    

```javascript
// packвозрастs\vтаблица\src\списоктаблица.ts
  */***
*   * 修改数据 支持多条数据*
*   * @param records 修改数据条目*
*   * @param recordIndexs 对应修改数据的索引（显示在body中的索引，即要修改的是body部分的第几行数据）*
*   */*
  updateRecords(records: любой[], recordIndexs: (число | число[])[]) {
    списоктаблицаUpdateRecords(records, recordIndexs, this);
  }    

```
#### списоктаблицаUpdateRecords

```Typescript
// packвозрастs\vтаблица\src\core\record-helper.ts
/**
 * 修改数据 支持多条数据
 * @param records 修改数据条目
 * @param recordIndexs 对应修改数据的索引（显示在body中的索引，即要修改的是body部分的第几行数据）
 */
export функция списоктаблицаUpdateRecords(records: любой[], recordIndexs: (число | число[])[], таблица: списоктаблица) {
  if (!recordIndexs?.length) возврат;

  if (таблица.options.groupBy) {
    // 优先判断是否配置分组
    (таблица.данныеSource as CachedданныеSource).updateRecordsForGroup?.(records, recordIndexs as число[]);
      // 通用更新流程，更新场景树
      таблица.scenegraph.clearCells();
      таблица.scenegraph.createSceneGraph();
  } else if ((таблица.данныеSource as CachedданныеSource).rowHierarchyType === 'tree') {
    // 树形结构
    (таблица.данныеSource as CachedданныеSource).updateRecordsForTree?.(records, recordIndexs as число[]);
    // 省略：通用更新流程，更新场景树
  } else if (таблица.сортировкаState) {
    // 配置了排序
    таблица.данныеSource.updateRecordsForсортировкаed(records, recordIndexs as число[]);
    сортировкаRecords(таблица);
    // 省略：通用更新流程，更新场景树
  } else {
    // 默认分支
    const updateRecordIndexs = таблица.данныеSource.updateRecords(records, recordIndexs);
    if (!updateRecordIndexs.length) возврат;
    if (таблица.pagination) {
        // 省略  
        // recordIndexsMinToMax 为需要更新的行号
        const updateRows = [];
        для (let index = 0; index < recordIndexsMinToMax.length; index++) {
          const recordIndex = recordIndexsMinToMax[index];
          // 这里只会去计算在当前页的需要更新的行
          if (recordIndex < endIndex && recordIndex >= endIndex - perPвозрастCount) {
           // 计算实际渲染行号（考虑表头、聚合行等因素），只计算在当前页的数据
            const rowNum =
              recordIndex -
              (endIndex - perPвозрастCount) +
              (таблица.transpose ? таблица.rowHeaderLevelCount : таблица.columnHeaderLevelCount) +
              topAggregationCount;
            updateRows.push(rowNum);
          }
        }
        if (updateRows.length >= 1) {
          // updateRowCells 为 上面计算出的 updateRows 跟聚合行的和
          таблица.transpose
            ? таблица.scenegraph.updateCol([], [], updateRowCells)
            : таблица.scenegraph.updateRow([], [], updateRowCells);
        }
      } else {
        const updateRows = [];
        // 省略：获取 updateRowCells
        // 计算方式为 需要更新的行加顶部和底部的聚合行
        таблица.transpose
            ? таблица.scenegraph.updateCol([], [], updateRowCells)
            : таблица.scenegraph.updateRow([], [], updateRowCells);
      }
  }
}    

```
списоктаблицаUpdateRecords is generally similar к списоктаблицаAddRecords, both have four situations. в the первый three situations, the scene tree will be directly updated. The difference lies в the по умолчанию branch; списоктаблицаUpdateRecords will не calculate addRows, it will only calculate updateRowCells.    \r

#### возможности Involved в данныеSource

* данныеSource.updateRecords: Modify records according к the index, и update currentIndexedданные и pagination данные;    \r

* CachedданныеSource.updateRecordsForгруппа: Update records и refresh Group status;    \r

*  данныеSource.updateRecordsForсортировкаed: Clear the сортировкаedIndexMap while updating records;    \r

* данныеSource.updateRecordsForTree: Update records while adjusting the tree structure expansion state; \r

### deleteRecords

deleteRecords is used к delete данные от a specified index. Consider whether deleting данные от a specified index can be similar к предыдущий методы, where в некоторые scenarios, the entire scene tree does не need к be updated.    \r

```javascript
// packвозрастs\vтаблица\src\списоктаблица.ts
  */***
*   * 删除数据 支持多条数据*
*   * @param recordIndexs 要删除数据的索引（显示在body中的索引，即要修改的是body部分的第几行数据）*
*   */*
  deleteRecords(recordIndexs: число[] | число[][]) {
    списоктаблицаDeleteRecords(recordIndexs, this);
    this.internalProps.emptyTip?.resetVisible();
  }    

```
#### списоктаблицаDeleteRecords

```Typescript
// packвозрастs\vтаблица\src\core\record-helper.ts
/**
 * 删除数据 支持多条数据
 * @param recordIndexs 要删除数据的索引（显示在body中的索引，即要修改的是body部分的第几行数据）
 */
export функция списоктаблицаDeleteRecords(recordIndexs: число[] | число[][], таблица: списоктаблица) {
  if (recordIndexs?.length > 0) {
    if (таблица.options.groupBy) {
      (таблица.данныеSource as CachedданныеSource).deleteRecordsForGroup?.(recordIndexs);
      // 省略
      // 更新整个场景树
    } else if ((таблица.данныеSource as CachedданныеSource).rowHierarchyType === 'tree') {
      (таблица.данныеSource as CachedданныеSource).deleteRecordsForTree?.(recordIndexs);
      // 省略
      // 更新整个场景树
    } else if (таблица.сортировкаState) {
      таблица.данныеSource.deleteRecordsForсортировкаed(recordIndexs as число[]);
      // 省略
      // 更新整个场景树
    } else {
      const deletedRecordIndexs = таблица.данныеSource.deleteRecords(recordIndexs as число[]);
      // 省略
      const oldRowCount = таблица.transpose ? таблица.colCount : таблица.rowCount;
      таблица.refreshRowColCount(); // 这里会去根据数据源重新调整行列数
      const newRowCount = таблица.transpose ? таблица.colCount : таблица.rowCount;
      if (таблица.pagination) {
        const { perPвозрастCount, currentPвозраст } = таблица.pagination;
        const startIndex = perPвозрастCount * (currentPвозраст || 0);
        const endIndex = startIndex + perPвозрастCount;
        if (minRecordIndex < endIndex) {
          // 删除当前页或者前面的数据才需要更新 如果是删除的是当前页后面的数据不需要更新场景树
          if (minRecordIndex < endIndex - perPвозрастCount) {
            // 如果删除包含当页之前的数据 则整个场景树都更新
          } else {
            const headerCount = таблица.transpose ? таблица.rowHeaderLevelCount : таблица.columnHeaderLevelCount;
            const topAggregationCount = таблица.internalProps.макетMap.hasAggregationOnTopCount;
            // 如果是仅删除当前页数据
            const minRowNum =
              minRecordIndex -
              (endIndex - perPвозрастCount) +
              (таблица.transpose ? таблица.rowHeaderLevelCount : таблица.columnHeaderLevelCount) +
              topAggregationCount;
            // 如果当页数据是满的 则更新影响的部分行
            const updateRows = [];
            const delRows = [];
            // 省略
            // 如果删除的是当前页的数据，则 minRowNum 到当前页最后一条都需要进行更新
            if (newRowCount < oldRowCount) {
              // 如果删除数据后出现当前页不满的情况，需要进行比较，删掉多的行，更新 delRows
            }
            таблица.transpose ? таблица.scenegraph.updateCol(delRows, [], updateRows) : таблица.scenegraph.updateRow(delRows, [], updateRows);
          }
        }
      } else {
        // 如果没有配置分页，跟上面的判断相同，通过计算得出实际需要更新和删除的行
        таблица.transpose ? таблица.scenegraph.updateCol(delRows, [], updateRows) : таблица.scenegraph.updateRow(delRows, [], updateRows);
      }
    }
  }
}    

```
#### возможности Involved в данныеSource

* данныеSource.deleteRecords: Delete данные от the specified index на records, while updating currentIndexedданные и pagination данные;    \r

* CachedданныеSource.deleteRecordsForгруппа: Delete records while refreshing the Group status;    \r

* данныеSource.deleteRecordsForTree: Clear the сортировкаedIndexMap while deleting records; \r

* данныеSource.deleteRecordsForTree: Adjust the tree structure expansion state while deleting records; \r

### данные Update Principle


от the above commonly used апиs, the logic для данные updates в списоктаблица is generally the same, consisting из four branches. в most scenarios, the по умолчанию branch is entered, where методы в данныеSource are первый called к update records и currentIndexedданные. Then, the actual rows that need к be updated are calculated. During the update, only scenegraph.updateCol is called к redraw the corresponding rows, thus achieving a DOM-like reuse operation. \r

### getCellValue

списоктаблица also provides us с the ability к obtain the display значение из a cell. Now let's loхорошо в how к get the displayed данные through pseudoкод:    \r

```javascript
// packвозрастs\vтаблица\src\списоктаблица.ts
*/** 获取单元格展示值 */*
getCellValue(col: число, row: число, skipпользовательскийMerge?: логический): поледанные {
  // 1. 无效坐标检查
  if (col === -1 || row === -1) возврат null
  
  // 2. 合并单元格处理（优先处理）
  if (!skipпользовательскийMerge) {
    const merged = this.getпользовательскийMergeValue(col, row)
    if (merged) возврат merged
  }

  // 3. 序号列处理
  if (isSeriesNumber) {
    if (表头中的序号列) возврат 标题
    else {
      // 分组表格的特殊序号计算
      значение = 分组模式 ? 获取分组序号 : 普通行号 
      возврат 应用格式化函数后的值
    }
  }
  
  // 4. 表头单元格处理
  else if (isHeader) {
    возврат 表头标题（支持函数形式）
  }
  
  // 5. 聚合单元格处理
  else if (isAggregation) {
    if (顶部聚合) возврат 聚合值格式化
    else if (底部聚合) возврат 聚合值格式化
  }

  // 6. 普通数据单元格
  const { поле } = таблица.internalProps.макетMap.getBody(col, row);
  возврат таблица.getполеданные(поле, col, row);
}    

```
#### getCellValue Flowграфик

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/X6NKwp3efhONa6bZhmKczmEQnng.gif)

#### getполеданные

getполеданные internally calls the данныеSource.getполе method, which uses currentIndexedданные к obtain the actual данные index, thereby retrieving the actual данные от the records.    \r

# Summary


* Modular данные processing: `@Visactor/Vтаблица` separates the данные processing из сводный таблицаs и базовый таблицаs into two parts. базовый таблицаs use данныеSource и CachedданныеSource, while сводный таблицаs use a more complex данныеSet class. This approach makes subsequent adjustments more convenient; 

* данные source abstraction: списоктаблица internally abstracts данные through данныеSource и CachedданныеSource, placing все logic within the module к reduce cognitive load during данные processing и achieve low coupling; \r

* Efficient данные processing: Since `@Visactor/Vтаблица` is rendered based на Canvas, it cannot be manipulated like native DOM when updating данные. списоктаблица cleverly avoids unnecessary rendering по calculating the rows that actually need к be updated и added, achieving efficient данные processing.    

# This document is provided по Следующий personnel


taiiiyang（https://github.com/taiiiyang）    



# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)