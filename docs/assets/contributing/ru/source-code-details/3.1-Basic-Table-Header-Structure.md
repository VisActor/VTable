---
заголовок: 3.1 базовый таблица Header Structure    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Introduction


базовый таблицаs differ от the complexity из сводный таблицаs, с only distinctions between rows и columns, и the structure из the header is relatively simple. Let's take a loхорошо в the relevant parts из the header structure из базовый таблицаs.    \r

## Scene Tree Related


Vтаблица manвозрастs the various modules из the таблица в the form из a scene tree. для the header из a базовый таблица, it mainly involves Следующий nodes:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/UkqRbiVtHonLpMxi9k0cOdmGnTf.gif' alt='' ширина='957' высота='авто'>

1. colHeaderGroup     

список header node: Responsible для managing the entire список header, the header part does не change позиция с scrolling;    \r

1. columnGroup    

Column группа: каждый column is a separate container, и базовыйally каждый column will have its own style configuration;    \r

1. cellGroup    

Cell node: каждый cell maintains its own copy, containing все the graphic elements that need к be rendered internally;    \r

1. rightTopCornerGroup    

Freeze the право-side список header: When configuring the право-side frozen columns, maintain a separate список header для the право side;    

1. cornerHeaderGroup    

лево frozen список header: Maintain the header part из the лево frozen column, equivalent к the corner header;    \r

## макет Module


The module related к the базовый таблица header макет is maintained separately в the `SimpleHeaderмакетMap` class, which contains a lot из макет-related logic и auxiliary functions. The most important are Следующий submodules.

### Original Column Definition Storвозраст


The original column definition is maintained separately на `interProps`, и separately maintained as `_columns` в `макетMap`. The difference is that для tree structures, `_columns` will only maintain a set из leaf nodes. This поле is mainly used для operations к obtain the число из columns и column definitions.


к achieve the column hiding feature, the nodes скрытый internally по Vтаблица are не placed в `columns`, but are stored separately в `columnsIncludeHided`, which contains все the leaf nodes.

### Dimension Tree


для such a multi-level header, it can be maintained в the form из a dimension tree. However, within the базовый таблица, maintaining a tree structure is too costly, so Vтаблица adopts another solution.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/I9xUbUGs0o1GkrxqFKycpFjUn3e.gif' alt='' ширина='472' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ZqY4bUgLMojIWSxP5x1cQ3vwnNh.gif' alt='' ширина='734' высота='авто'>

### Tree Structure Alternatives


Since implementing a tree structure is too difficult, what can be done к reduce the complexity из handling tree structures? This is how Vтаблица solves it internally:    \r

для the таблица header, flatten the definition из the columns, define an index для каждый column, и establish a mapping таблица between the index и the column definition; в the same time, generate a two-dimensional header ID matrix based на the макет из the таблица, generate the corresponding index в the corresponding row и column, use the row и column numbers к get the id, и then obtain the column definition на the corresponding cell according к the id.    \r

The flattened column definition mapping таблица is maintained в `макетMap._headerObjectMap`, и the two-dimensional данные index is maintained в `layouMap._headerCellIds`.    

Let's take the above tree structure as an пример,    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/TS5ubIMU2oe3QtxMRKEcWXYvnkf.gif' alt='' ширина='447' высота='авто'>

_headerCellIds loхорошоs like this    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GIetbByq9oZTAwxPm7Vc8Au2nlc.gif' alt='' ширина='459' высота='авто'>

Corresponding _headerObjectsMap mapping таблица:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/RTINb9ccuoT5t0xsUVhcq4Eun2d.gif' alt='' ширина='1000' высота='авто'>

по decoupling the tree structure into a данные index таблица corresponding к каждый row и column's id и a mapping таблица из id к column definitions, apart от needing к maintain the header ID matrix when the header structure changes, the simpliГород из obtaining column definitions и Производительность в terms из storвозраст are far superior к directly storing the tree structure.    \r

### Merged Cell Range Cache


в the case where there is a merged header в the базовый таблица header, there is a need к determine which range the текущий cell is в based на the row и column numbers. If you frequently judge based на the original structure, it will cause a great Производительность waste. Therefore, `макетMap` internally stores a cache из merged cell ranges `_cellRangeMap`. This mapping таблица uses `${col}_${row}` as the key, и the cellRange where the текущий cell is located as the значение.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Bcw9bgiuIomGzWxS1mLckMBCnTe.gif' alt='' ширина='380' высота='авто'>

If there is a need к obtain the range based на row и column numbers в the future, Вы можете directly use this mapping таблица к get it. It should be noted that after the header позиция is dragged, the cached row и column numbers are no longer accurate и need к be reset.

## Module Generation


The above introduces several important modules в `макетMap` и their usвозраст. Let's see how каждый module is generated during initialization:

### Header ID Matrix


Since the generation из the header ID matrix и the header definition mapping are both completed в the same функция ` _addHeader`, it is quite challenging к directly understand this functional feature. Here, we will первый separate the two parts из the logic и take a loхорошо в the generation из the данные index таблица part:

Taking the tree header в the above figure as an пример, let's loхорошо в the generation logic из `_headerCellIds`.    

```Typescript
  const columns = [
    {
      поле: 'id',
      заголовок: 'ID',
    },
    {
      заголовок: 'имя',
      columns: [
        {
          поле: 'имя1',
          заголовок: 'имя1',
        },
        {
          заголовок: 'имя-level-2',
          columns: [
            {
              поле: 'имя2',
              заголовок: 'имя2',
            },
            {
              заголовок: 'имя3',
              поле: 'имя3',
            }
          ]
        }
      ]
    }
  ];    

```
#### функция Simplification


Here is the simplified logic для generating `_headerCellIds`:    

```Typescript
// packвозрастs\vтаблица\src\макет\simple-header-макет.ts
const _columns = [];
let seqId = 0;
const _headerCellIds = [];

функция _addHeaders(row, column, roots) {
  const rowCells = _newRow(row);
  column.forEach(hd => {
    const col = _columns.length;
    const id = seqId++;
    для (let r = row - 1; r >= 0; r--) {
      _headerCellIds[r] && (_headerCellIds[r][col] = roots[r]);
    }
    rowCells[col] = id;
    if (hd.columns) {
      _addHeaders(row + 1, hd.columns, [...roots, id]);
    } else {
      _columns.push(hd);
      seqId++;
      для (let r = row + 1; r < _headerCellIds.length; r++) {
        _headerCellIds[r][col] = id;
      }
    }
  });
}    

```
#### Single Line Index Generation


Before parsing the logic в detail, let's первый see how the текущий line's rowCells are associated through line numbers:

When generating lines, there will be two situations:    \r

1. If the текущий line already exists, it will be completed based на the данные от the предыдущий line, и the address из the текущий line will be returned;    \r

1. If the текущий row does не exist, a newRow will be generated, associated с _headerCellIds[row], и then the information от the предыдущий layer will be synchronized к newRow, returning the address из newRow. This way, when modifying rowCells, it can be synchronized к `_headerCellIds`.    

![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/IYoIw7tCOhmXCjbPWeicPZZOnPh.gif)

#### _headerCellIds Changes

Here is the change в the `addHeaders` process, `headerCellIds`:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/O0gBbczpPoJllKxJFf3cyLYWnZc.gif' alt='' ширина='1000' высота='авто'>

#### Generation Process


It can be seen that the число из columns в the final generated _headerCellIds is determined по the breadth из the columns tree, while the число из rows is determined по the depth из the tree.    

The generation process is mainly through depth-первый traversal. Before traversing the columns, rowCells и _headerCellIds will be associated первый. \r

During the traversal из the columns, before processing the текущий node, if there is a node в the same column в the upper level, the node в the same column в the upper level will be updated.    

After processing the предыдущий layer, update the index для the текущий row и column.    

If there is a subtree, recursion will continue к update roots, which represents the path от the root node к the текущий node.    \r

If there is no subtree, the nodes below this column will be updated, и then the следующий iteration will begin. After the recursion is complete, it indicates that the update из _headerCellIds is finished.    \r

### Header Mapping


The generation из the header mapping relative к the header ID matrix is relatively simple, it is just a recursive process.    

```Typescript
// packвозрастs\vтаблица\src\макет\simple-header-макет.ts
      функция _addHeaders(row, column) {
        const results = [];
        column.forEach((hd) => {
          const id = seqId++;
          const cell = {
            id,
            заголовок: hd.title ?? hd.caption,
            ...
          };
          results[id] = cell;
          if (hd.columns) {
            _addHeaders(row + 1, hd.columns).forEach((c) => results.push(c));
          } else {
            seqId++;
          }
        });
        возврат results;
      }    

```
![](https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/FBeUwdZechOoUwbhKDCch1k8nof.gif)

After recursion, _headerObjectsIncludeHided loхорошоs like this:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/TJbLbQDsnoiLa1xJDf7cPVmQnOf.gif' alt='' ширина='1000' высота='авто'>

Subsequently processed through reduce к generate _headerObjectMap    

```Typescript
// packвозрастs\vтаблица\src\макет\simple-header-макет.ts
this._headerObjectMap = this._headerObjects.reduce((o, e) => {
  o[e.id] = e;
  возврат o;
}, {});    

```
<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/TbbLbz5Tpos0xUxFBXQcT3ROn7b.gif' alt='' ширина='1000' высота='авто'>

## Conclusion


The structure из a базовый таблица is simpler compared к a сводный таблица, as it only requires maintaining the список header.    

The header structure is divided into several important modules:    \r

*  _headerCellIds: Responsible для managing the index из the column definition corresponding к the текущий row и column число;    \r

*  _headerObjectMap: Mapping таблица из column index и column definition;    \r

*  _columns: maintain the leaf nodes из the таблица header structure;    \r

# This document is provided по Следующий personnel


taiiiyang( https://github.com/taiiiyang)     



# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)