---
заголовок: 4.1 Vтаблица событие Design    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Introduction


This article will explain Следующий contents:    

1. What is an событие module    

1. Why is the событие module needed    

1. The concept из событиеs в Vтаблица    

1. Design и Module Division из the событие System в Vтаблица    

## What is an событие System


A project often consists из multiple modules. During the development process, there will inevitably be situations where one module depends на multiple modules, и multiple modules simultaneously depend на one module. As the project grows, relying solely на direct interaction between modules will increase the coupling из the project.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Qh9Sb1ccPog0mHxVUXUchatTntd.gif' alt='' ширина='873' высота='авто'>

без an событие system, if you need к notify affected modules, каждый module that triggers an событие must notify все списокening modules. Этоn n-n relationship, и as the project grows, maintaining this relationship becomes very complex.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/PNFWbZBczoaDrrxFzfWc2lzQnEc.gif' alt='' ширина='723' высота='авто'>

This is when the событие system comes into play.    

The main функция из the событие system is к decouple dependencies. After introducing the событие system, все событие manвозрастment can be stored в the событие system.    

The событие system is equivalent к a transit station и is не responsible для business logic, или it rarely handles business logic. It only списокens к событиеs и uniformly dispatches them. Other modules only need к be concerned с the событие system и do не need к spend effort maintaining relationships с other dependent modules.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/UaIwbYpClofWfJxUDslc9jg0nGe.gif' alt='' ширина='889' высота='авто'>

от the above figure, it can be observed that the событие trigger will only involve the событие system, и the событие списокener will only списокen к событиеs triggered по the событие system. This way, the original n-n relationship can be converted into a 1-n relationship, reducing the coupling between modules.    \r

## событиеs в Vтаблица


в JS, событиеs mainly refer к specific behaviors в the browser, such as mouse Нажатьs и wheel scrolling. Through событие-driven programming, users are allowed к create interactive web pвозрастs.    

However, the событиеs в the Vтаблица are не limited к native browser событиеs; they also include пользовательский событиеs.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Hx8qb8XDCo9tRXxzdUhcjB8snvd.gif' alt='' ширина='589' высота='авто'>

Vтаблица списокens к both пользовательский событиеs и native browser событиеs в the same time    

Native browser событиеs, including but не limited к:    

*  touchstart    

*  touchотмена    

*  touchmove    

*  touchend    

*  pointermove    

*  pointerup    

*  pointerdown    

пользовательский событиеs: Unlike native browser событиеs, they are only triggered в specific business logic, mainly utilizing the publish-subscribe module в Vтаблица к achieve this. пользовательский событиеs include but are не limited к:    

*  Нажать_CELL    

*  DBLНажать_CELL    

*  DBLTAP_CELL    

*  MOUSEDOWN_CELL    

*  MOUSEUP_CELL    

*  SELECTED_CELL    

*  CONTEXTменю_CELL    

*  DRAG_SELECT_END    

## событие System Design


The событие system is mainly responsible для several tasks, including списокening к DOM событиеs, triggering пользовательский событиеs, и updating the state manвозрастment module. следующий, let's loхорошо в the module division и implementation ideas из the событие system.    \r

---
The событие system в Vтаблица is mainly implemented по Следующий modules.    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ZoEAbm23mogrTIxwItYcx3oGnAf.gif' alt='' ширина='1000' высота='авто'>

#### событиеTarget

*  vтаблица\src\событие\событиеTarget.ts    

`событиеTarget` is the lowest level из пользовательский событие implementation в the событие system, implementing the publish-subscribe функциональность.

There are three important modules inside Vтаблица, все derived от событиеTarget;    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/LXSobR0kvoe9UCxCHzMc9iiYnag.gif' alt='' ширина='515' высота='авто'>

Due к the presence из `событиеTarget`, Vтаблица can more easily create и списокen к пользовательский событиеs. для пример, if we want к списокen к a пользовательский событие из an иконка Нажать, we only need к call the на method и pass в the corresponding обратный вызов, then the обратный вызов will be executed directly when the событие is triggered later.

```Typescript
// packвозрастs\vтаблица\src\событие\событие.ts
*// 图标点击*
this.таблица.на(таблица_событие_TYPE.иконка_Нажать, иконкаInfo => {
// 改变状态管理模块
});    

```
Through the `событиеTarget` module, it is very convenient к implement the пользовательский событие module в Vтаблица событиеs.    

We take the initialization из a базовый таблица as an пример, during which several main пользовательский событиеs are bound.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/JrMRb9rvNoSiVqxXNtBcD95Gn8e.gif' alt='' ширина='582' высота='авто'>

в addition, the user-defined registration feature provided по Vтаблица also relies на this module.    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/JpHmboOG8oE37mxxNh6cQPYNnNg.gif' alt='' ширина='971' высота='авто'>

*  Here is the general architecture из событиеTarget    

```Typescript
// packвозрастs\vтаблица\src\событие\событиеTarget.ts
export class событиеTarget {
  private списокenersданные: {
    списокeners,
    списокenerданные
  } = {
    списокeners: {},
    списокenerданные: {}
  };
  на(тип, списокener) {
      //...
  }
  off(idOrType, списокener): void {
      //...
  }
  addсобытиесписокener(тип, списокener, option): void {
      //...
  }
  removeсобытиесписокener(тип, списокener) {
      //...
  }
  hasсписокeners(тип) {
      //...
  }
  fireсписокeners(тип, событие){
      //...
  }
  Релиз(): void {
      //...
  }
}    

```
#### событиеHandler

`событиеHandler` mainly adopts the observer и publish-subscribe pattern. The difference between it и `событиеTarget` is that `событиеTarget` is mainly responsible для пользовательский событиеs, while `событиеHandler` is mainly responsible для списокening к native DOM событиеs, including but не limited к:    

*  copy    

*  paste    

*  contextменю    

*  изменение размера    

*  потеря фокуса    

The method из регистрацияing callbacks is the same as the `событиеTarget` method, both using the `на` method. The difference is that `событиеHandler` mainly списокens к native DOM elements.

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\container-dom.ts
handler.на(таблица.getElement(), 'потеря фокуса', (e: Mouseсобытие) => {})
handler.на(таблица.getElement(), 'keydown', (e: Keyboardсобытие) => {})
handler.на(таблица.getElement(), 'copy', async (e: Keyboardсобытие) => {})
handler.на(таблица.getElement(), 'contextменю', (e: любой) => {}）    

```
There are also differences в the implementation из the `на` method. по observing the source код, we can see that when регистрацияing обратный вызов событиеs, it checks для the existence из `addсобытиесписокener`, which allows для native DOM событие списокening.

```Typescript
// packвозрастs\vтаблица\src\событие\событиеHandler.ts
export class событиеHandler {
 на(
    target: HTMLElement | Window | событиеHandlerTarget,
    тип: строка,
    списокener: списокener,
    ...options: любой[]
  ): событиесписокenerId {
    if (Env.mode === 'node') {
      возврат -1;
    }
    const id = idCount++;
    if (target?.addсобытиесписокener) {
      if (тип !== 'изменение размера' || (target as Window) === window) {
        (target as событиеTarget)?.addсобытиесписокener(тип, списокener, ...(options as []));
      } else {
        const resizeObserver = новый ResizeObserver(target as HTMLElement, списокener, this.resizeTime);
        this.reseizeсписокeners[id] = resizeObserver;
      }
    }
    const obj = { target, тип, списокener, options };
    this.списокeners[id] = obj;
    возврат id;
  }
  // ...
 }    

```
#### событиеManвозрастr

`событиеManвозрастr` is the событие manвозрастr из Vтаблица, which provides a unified интерфейс для handling событиеs within Vтаблица. It is responsible для списокening к most событиеs и регистрацияing пользовательский событиеs, including native DOM событиеs и пользовательский событиеs.

*  Source код    

```Typescript
// packвозрастs\vтаблица\src\событие\событие.ts
export class событиеManвозрастr {
  constructor(таблица: Baseтаблицаапи) {
    // 事件绑定，这里包括了场景树中的事件以及原生 DOM 事件
    this.bindOuterсобытие();
    setTimeout(() => {
      // 注册自定义事件
      this.bindSelfсобытие();
    }, 0);
  }
  bindOuterсобытие() {
    bindтаблицаGroupсписокener(this);
    bindContainerDomсписокener(this);
    bindScrollBarсписокener(this);
    bindTouchсписокener(this);
    bindGesture(this);
  }
}    

```
*  bindтаблицаGroupсписокener    

Let's take `bindтаблицаGroupсписокener` as an пример, where the списокening и обратный вызов registration для external событиеs provided по `таблицаGroup` is completed within the функция. в the callbacks из these external событиеs, it will be determined based на specific business logic whether к trigger пользовательский событиеs.    

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointermove', (e: FederatedPointerсобытие) => {
таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointerout', (e: FederatedPointerсобытие) => {
таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointerover', (e: FederatedPointerсобытие) => {
// ...    

```
*  bindSelfсобытие    

`bindSelfсобытие` mainly регистрацияs пользовательский событиеs, including but не limited к иконка_Нажать и DROPDOWN_меню_Нажать, и the событие registration функциональность relies на `событиеTarget`.    

```Typescript
// packвозрастs\vтаблица\src\событие\событие.ts
  bindSelfсобытие() {
     // ...
    *// 图标点击*
    this.таблица.на(таблица_событие_TYPE.иконка_Нажать, иконкаInfo => {
       // ...
    });
    *// 下拉菜单内容点击*
    this.таблица.на(таблица_событие_TYPE.DROPDOWN_меню_Нажать, () => {
      // ...
    });
    this.updateсобытиеBinder();
    *// link/imвозраст/video点击*
    bindMediaНажать(this.таблица);
    *// 双击自动列宽*
    this.таблица.на(таблица_событие_TYPE.DBLНажать_CELL, (e: MousePointerCellсобытие) => {
        // ...
    });
    *// drill иконка*
    if (this.таблица.isсводныйтаблица() && checkHaveDrill(this.таблица as сводныйтаблица)) {
      bindDrillсобытие(this.таблица);
    }
    *// график навести*
    bindSparklineHoverсобытие(this.таблица);
    *// axis Нажать*
    bindAxisНажатьсобытие(this.таблица);
    *// график axis событие*
    bindAxisHoverсобытие(this.таблица);
    *// group title флажок change*
    bindGroupTitleCheckboxChange(this.таблица);
  }    

```
в simple terms, `bindOuterсобытие` completes the событие списокening, и `bindSelfсобытие` completes the registration из пользовательский событиеs.    

## Conclusion


The событие system из Vтаблица is mainly divided into two parts:    \r

1. Native DOM событие списокening, handling DOM событиеs;    

1. External событие списокening, including событиеs bubbling up от the Stвозраст, к determine whether к trigger пользовательский событиеs based на specific conditions.    

по splitting the interaction из the таблица into событие modules и state modules, the событие module mainly triggers списокening и triggering, while the state module is responsible для maintaining the internal state из the таблица, implementing the logic из событие change -> state change -> таблица rendering. This modular approach can better reduce the coupling between project modules.

# This document is provided по Следующий personnel


taiiiyang（https://github.com/taiiiyang）    



# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)