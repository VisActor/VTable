---
title: 2.2 Элементы VTable и Выражение Отношений с Деревом Сцены    

key words: VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Визуализация,Диаграмма,Данные,Таблица,График,ГИС,LLM
---
Каков процесс от кода до живой таблицы, представленной нам в VTable? По моему пониманию, VTable сначала создает экземпляр Table, затем инициализирует каждый модуль элементов таблицы, рендеря элемент Canvas. **При инициализации модуля элементов SceneGraph создает stage Stage и генерирует контейнеры структуры базовых узлов дерева сцены различных типов.** Впоследствии модуль DataSet обрабатывает внутренние данные таблицы для создания различных структур данных в соответствии с различными требованиями отображения данных. Кроме того, с помощью других модулей, таких как модуль Layout и модуль Event, таблица наделяется аккуратным макетом и интерактивными функциями. После завершения всех приготовлений вызывается возможность рендеринга базового VRender для отрисовки абстрактной структуры дерева сцены в красочную таблицу согласно чертежу Stage, который мы упомянули ранее.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DHefbI3iZo1kW7xb4COc1Mnjn7b.gif' alt='' ширина='1000' высота='auto'>



Эта статья объясняет процесс инициализации контейнера таблицы в дереве сцены;    

## Соответствующие Расположения Исходного Кода


*  package/VTable/src/scenegrapg/groupcreater/init-scenegraph.ts Инициализация контейнера графа сцены    

*  package/VTable/src/core/BaseTable.ts Файл определения основного класса дерева сцены    

* package/VTable/src/scenegraph/grapghic/group.ts - это класс Group для расширения рендеринга таблицы, используемый для управления макетом, размером и рендерингом таблицы. Окончательно возвращаемый экземпляр является объектом группы в таблице, который может быть группой ячеек, группой заголовков, группой замороженных столбцов и т.д. 

## Процесс Инициализации


### Initialization из the Root Node


```xml
 scene.tableGroup = новый Group({
      x: 0, 
      y: 0,
      ширина,
      высота,
      clip: true, pickable: false 
  });
  scene.tableGroup.role = 'table';    

```
> <img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ZFN6boBuBo7lljxdpU0cGTH5ndc.gif' alt='' ширина='1000' высота='auto'>
> <img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/RprMb1GIToX8e4xCoz0cvfcanjb.gif' alt='' ширина='1000' высота='auto'>
> Here is the VRender documentation regarding the Group class, explaining the two properties: clip и pickable. When creating a Group, coordinates, dimensions, и these two properties will be configured.

pickable: Whether the primitive can be interactive. If false, it will не respond к любой events (only display, no interaction)    \r

clip: After setting the group к clip, it will crop the parts из child elements that exceed the range based на ширина и высота (similar к overflow: скрытый)    \r

### Initialization из the Remaining Nodes в the Scene Tree


```xml
функция initSceneGraph(scene: Scenegraph) {
  const ширина = scene.table.tableNoFrameWidth;
  const высота = scene.table.tableNoFrameHeight;

  // 根容器
  scene.tableGroup = новый Group({ x: 0, y: 0, ширина, высота, clip: true });

  // 创建各子容器的Group实例
  const colHeaderGroup = createContainerGroup(
    0,
    0,
    !(scene.table.options as ListTableConstructorOptions).enableTreeStickCell
  );
  
  //设置colHeader的role属性为'col-header'
  colHeaderGroup.role = 'col-header';
  scene.colHeaderGroup = colHeaderGroup;
}



    

```
> Here, the creation source code из ColHeaderGroup is used as an example    

---
```xml
функция createContainerGroup(ширина: число, высота: число, clip?: логический) {
  возврат новый Group({
    x: 0,
    y: 0,
    ширина,
    высота,
    clip: clip ?? false,
    pickable: false
  });
}
    

```
> The process из createContainerGroup returning a Group instance    



### Add к Root Node


```xml
scene.tableGroup.addChild(bodyGroup);
scene.tableGroup.addChild(rowHeaderGroup);
scene.tableGroup.addChild(bottomFrozenGroup);
//...
//其余节点类似    

```
Add the generated different nodes к the root node в sequence, indicating в the source code comments that different addition orders may have a certain impact;    \r

## Summary




в the scenegraph class, when initializing the scene tree, the текущий Scenegraph instance is passed into the initSceneGraph функция (от /init-scenegraph.ts). It is не difficult к see от initSceneGraph that different types из table subunits возврат a Group instance through `createContainerGroup` while creating the scene tree, и then set the `role` attribute на the instance к identify its функция, finally adding them к the root container `TableGroup` respectively.

в this point, the initialization part из the container is complete, и container nodes (Group) из different types из elements в the scene tree have been generated.







# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)