---
title: 2.2 Элементы VTable и Выражение Отношений с Деревом Сцены    

key words: VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Визуализация,Диаграмма,Данные,Таблица,График,ГИС,LLM
---
Каков процесс от кода до живой таблицы, представленной нам в VTable? По моему пониманию, VTable сначала создает экземпляр Table, затем инициализирует каждый модуль элементов таблицы, рендеря элемент Canvas. **При инициализации модуля элементов SceneGraph создает stage Stage и генерирует контейнеры структуры базовых узлов дерева сцены различных типов.** Впоследствии модуль DataSet обрабатывает внутренние данные таблицы для создания различных структур данных в соответствии с различными требованиями отображения данных. Кроме того, с помощью других модулей, таких как модуль Layout и модуль Event, таблица наделяется аккуратным макетом и интерактивными функциями. После завершения всех приготовлений вызывается возможность рендеринга базового VRender для отрисовки абстрактной структуры дерева сцены в красочную таблицу согласно чертежу Stage, который мы упомянули ранее.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DHefbI3iZo1kW7xb4COc1Mnjn7b.gif' alt='' width='1000' height='auto'>



Эта статья объясняет процесс инициализации контейнера таблицы в дереве сцены;    

## Соответствующие Расположения Исходного Кода


*  package/vtable/src/scenegrapg/groupcreater/init-scenegraph.ts Инициализация контейнера графа сцены    

*  package/vtable/src/core/BaseTable.ts Файл определения основного класса дерева сцены    

* package/vtable/src/scenegraph/grapghic/group.ts - это класс Group для расширения рендеринга таблицы, используемый для управления макетом, размером и рендерингом таблицы. Окончательно возвращаемый экземпляр является объектом группы в таблице, который может быть группой ячеек, группой заголовков, группой замороженных столбцов и т.д. 

## Процесс Инициализации


### Initialization of the Root Node


```xml
 scene.tableGroup = new Group({
      x: 0, 
      y: 0,
      width,
      height,
      clip: true, pickable: false 
  });
  scene.tableGroup.role = 'table';    

```
> <img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ZFN6boBuBo7lljxdpU0cGTH5ndc.gif' alt='' width='1000' height='auto'>
> <img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/RprMb1GIToX8e4xCoz0cvfcanjb.gif' alt='' width='1000' height='auto'>
> Here is the VRender documentation regarding the Group class, explaining the two properties: clip and pickable. When creating a Group, coordinates, dimensions, and these two properties will be configured.

pickable: Whether the primitive can be interactive. If false, it will not respond to any events (only display, no interaction)    \r

clip: After setting the group to clip, it will crop the parts of child elements that exceed the range based on width and height (similar to overflow: hidden)    \r

### Initialization of the Remaining Nodes in the Scene Tree


```xml
function initSceneGraph(scene: Scenegraph) {
  const width = scene.table.tableNoFrameWidth;
  const height = scene.table.tableNoFrameHeight;

  // 根容器
  scene.tableGroup = new Group({ x: 0, y: 0, width, height, clip: true });

  // 创建各子容器的Group实例
  const colHeaderGroup = createContainerGroup(
    0,
    0,
    !(scene.table.options as ListTableConstructorOptions).enableTreeStickCell
  );
  
  //设置colHeader的role属性为'col-header'
  colHeaderGroup.role = 'col-header';
  scene.colHeaderGroup = colHeaderGroup;
}



    

```
> Here, the creation source code of ColHeaderGroup is used as an example    

---
```xml
function createContainerGroup(width: number, height: number, clip?: boolean) {
  return new Group({
    x: 0,
    y: 0,
    width,
    height,
    clip: clip ?? false,
    pickable: false
  });
}
    

```
> The process of createContainerGroup returning a Group instance    



### Add to Root Node


```xml
scene.tableGroup.addChild(bodyGroup);
scene.tableGroup.addChild(rowHeaderGroup);
scene.tableGroup.addChild(bottomFrozenGroup);
//...
//其余节点类似    

```
Add the generated different nodes to the root node in sequence, indicating in the source code comments that different addition orders may have a certain impact;    \r

## Summary




In the scenegraph class, when initializing the scene tree, the current Scenegraph instance is passed into the initSceneGraph function (from /init-scenegraph.ts). It is not difficult to see from initSceneGraph that different types of table subunits return a Group instance through `createContainerGroup` while creating the scene tree, and then set the `role` attribute on the instance to identify its function, finally adding them to the root container `TableGroup` respectively.

At this point, the initialization part of the container is complete, and container nodes (Group) of different types of elements in the scene tree have been generated.







# This document was revised and organized by the following personnel 
 [玄魂](https://github.com/xuanhun)