---
заголовок: 3.3 Row высота, Column ширина Calculation    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## фон из the Requirement

During the rendering process из the таблица, cells are generated, but unlike the native DOM, Canvas cells cannot be expanded по content. We must know the row высота и column ширина из the content в order к dynamically adjust the ширина и высота из the cells based на the row высота и column ширина.


### Solution


Suppose we have a piece из текст     \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/CpLIbXURWoMWixxpW4qcaFn9nIc.gif' alt='' ширина='378' высота='авто'>

We want к calculate its ширина и высота through Canvas, the usual operation is like this:    \r

```javascript
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
ctx.шрифт = ....
let measure = ctx.measureText("@Visactor/Vтаблица");
const { 
  actualBoundingBoxLeft，
  actualBoundingBoxRight，
  actualBoundingBoxAscent，
  actualBoundingBoxDescent, 
  ширина 
} = measureText;
const realширина = Math.max(actualBoundingBoxLeft + actualBoundingBoxRight, ширина);
const высота = actualBoundingBoxAscent + actualBoundingBoxDescent;
console.log(realширина，высота);    

```
### Limitations


However, this method can only obtain the most базовый ширина и высота, but there are many other influencing factors within the Vтаблица, such as wrapping operations, which will affect the final calculation из ширина и высота. So how к accurately calculate row высота и column ширина для different configurations becomes a challenge. следующий, let's see how the Vтаблица operates internally.    \r

## Bounding Box


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/ZKj4bIrZ2o28FfxajKucgjuanlg.gif' alt='' ширина='529' высота='авто'>

Before introducing the specific calculation logic, it is necessary к первый introduce the concept из bounding boxes.    \r

в the поле из computer и graphic vision, a bounding box is a container that encloses a group из objects. по wrapping complex objects в simple containers, it is possible к approximate the shape из complex geometries с simple bounding boxes, which can improve computational efficiency. Additionally, simple objects are generally easier к check для overlap с каждый other.    \r

в VRender, AABBBounds is implemented. AABBBounds is a relatively simple тип из bounding box с poor tightness. Within Vтаблица, каждый базовый primitive maintains its own AABBBounds, which can be used к calculate ширина и высота.

Record the coordinates из the four vertices из the текущий bounding box в the AABBBounds instance. с the concept из a bounding box, it becomes much more convenient к implement functions such as ширина и высота calculation, rotation, и cropping.    \r

для пример, if we want к get the высота из a piece из текст, we can directly calculate it using `this.y2 - this.y1`.    

```Typescript
// VisActor/VUtil/blob/main/packвозрастs/vutils/src/данные-structure/bounds.ts
export class Bounds implements IBounds {
  // 默认初始值是Number.MAX_VALUE
  x1: число;
  y1: число;
  x2: число;
  y2: число;

  constructor(bounds?: Bounds) {
    if (bounds) {
      this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
    } else {
      this.clear();
    }
  }
  // ...
  rotate(angle: число = 0, x: число = 0, y: число = 0) {
    const p = this.rotatedPoints(angle, x, y);
    возврат this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  }
  ширина(): число {
    if (this.empty()) {
      возврат 0;
    }
    возврат this.x2 - this.x1;
  }
  высота(): число {
    if (this.empty()) {
      возврат 0;
    }
    возврат this.y2 - this.y1;
  }    

```
Related Documents    

*  [包围盒概念](https://baike.baidu.com/item/%E5%8C%85%E5%9B%B4%E7%9B%92/4562345)    

*  https://visactor.com/vrender/guide/asd/Часто Задаваемые Вопросы/What_Is_BoundsPadding    

## базовый ширина и высота Calculation


The underlying calculation из the ширина и высота из the Vтаблица relies на the AABBBounds provided по Visactor/Vutils к complete the calculation.    \r

*  Accurate calculation из текст ширина и высота    \r

первый, use getTextBounds к get the bounding box corresponding к the текст, и then use the internal ширина и высота к get the dimensions. \r

```Typescript
  // VisActor/VUtil/blob/main/packвозрастs/vutils/src/graphics/текст/measure/textMeasure.ts
  /** 精确计算文本宽高 */
  fullMeasure(текст: TextMeasureInput): ITextSize {
    if (isNil(текст)) {
      возврат { ширина: 0, высота: 0 };
    }
    if (isNil(this._option.getTextBounds) || !this._notSupportVRender) {
      возврат this.measureWithNaiveCanvas(текст); // 降级
    }
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineвысота } = this.textSpec;
    let размер: ITextSize;
    //...
     const bounds = this._option.getTextBounds({
        текст,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineширина: limit || Infinity,
        lineвысота
      });
     размер = { ширина: bounds.ширина(), высота: bounds.высота() };
     //...
    возврат размер;    

```
* Use native Canvas к calculate ширина и высота    

When encountering situations where VRender is не supported, native Canvas will be used к perform calculations.    

```Typescript
// VisActor/VUtil/blob/main/packвозрастs/vutils/src/graphics/текст/measure/textMeasure.ts
  protected _measureWithNaiveCanvas(текст: строка): ITextSize {
    if (!this.initContext()) {
      возврат this._quickMeasureWithoutCanvas(текст); // 降级
    }
    const metrics = this._context!.measureText(текст);
    const { fontSize, lineвысота } = this.textSpec;
    возврат {
      ширина: metrics.ширина,
      высота: (lineвысота as число) ?? fontSize,
      fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
      fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
    };
  }
    

```
## Column ширина Calculation


Let's первый loхорошо в the calculation из column ширина    \r

### Column ширина Calculation Mode


таблица column ширина calculation modes, there are three configurations below:    

* 'standard': Use the ширина attribute specified ширина as the column ширина.

* 'adaptive': Use the ширина из the таблица container к allocate column ширинаs.    

*  'автоширина': автоmatically calculate the column ширина based на the content в the column header и body cells, ignoring the ширина attribute setting.    

### Calculation Process


#### Impact в Different Calculation Modes


к calculate the column ширина из an entire column, it is не enough к obtain the column ширина из a single row. Instead, you need к find the maximum column ширина в the entire column (this has different effects under different calculation modes).

Assuming there are Следующий three cells, the content length из the three cells is не the same, Вы можетеnot randomly take the ширина из one cell as the column ширина для this column, there must be a definite ширина.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QwIKb6bB7oerLTx20C2cvWc4ndh.gif' alt='' ширина='519' высота='авто'>

в Vтаблица, different calculation modes для column ширинаs have different logic для adjusting column ширинаs:    \r

*  standard    

Under standard ширина, все ширинаs will follow the по умолчанию configuration;    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/JTRPbhucfozkXExx5zIcF1DUnze.gif' alt='' ширина='1000' высота='авто'>

для пример, the column ширина из the three cells above will be uniformly adjusted к 80px;    \r

*  автоширина    

в автоширина mode, the ширина из the entire column will be adjusted based на the longest column among все columns. It should be noted that the maximum column ширина cannot exceed `limitMaxавтоширина`;

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/CO3xbFXReoJUfLxQvLRcCFMinMe.gif' alt='' ширина='1000' высота='авто'>

*  adaptive    

в the container ширина adaptation mode, the column ширина is первый calculated based на автоширина, и then the column ширина is proportionally scaled according к the ratio из the container column ширина к the actual column ширина.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/C6NxbzzeHoARy6xu9PSci8g0nLf.gif' alt='' ширина='1000' высота='авто'>

#### Multi-column ширина Calculation


Here is the overall flowграфик с multiple column ширинаs    

*  computeColsширина (packвозрастs\vтаблица\src\scenegraph\макет\compute-col-ширина.ts)    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/NYiAbWKgzoIbEvx9pmlcShscn2f.gif' alt='' ширина='1000' высота='авто'>

Internally, it will traverse по column и call `computeColширина` для каждый column к calculate the ширина из the column separately.    

#### Single Column ширина Calculation


*  computeColширина    

##### Pre-process


в the process из obtaining the overall column ширина, каждый column is traversed к get the ширина из that column. Depending на the columnширинаComputeMode, different rows are involved в calculating the ширина из the column.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/BbYzwdNeQhoW7vbSxdVcmr28nt5.gif' alt='' ширина='820' высота='авто'>

##### Source код

```Typescript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-col-ширина.ts
export функция computeColширина(
  col: число,
  startRow: число,
  endRow: число,
  таблица: Baseтаблицаапи,
  forceCompute: логический = false *//forceCompute如果设置为true 即便不是自动列宽的列也会按内容计算列宽*
): число {
  // 先判断列宽缓存里的列宽，再判断是否配置中针对该列定义了列宽
  let ширина = getColширинаDefinedширинаResizedширина(col, таблица);
  
  if (
    таблица.internalProps.transpose &&
    ширина === 'авто' &&
    ((таблица.columnширинаComputeMode === 'only-header' && col >= таблица.rowHeaderLevelCount) ||
      (таблица.columnширинаComputeMode === 'only-body' && col < таблица.rowHeaderLevelCount))
  ) {
    ширина = таблица.getDefaultColumnширина(col);
  }

  if (forceCompute && !таблица.internalProps.transpose) {
    возврат computeавтоColширина(ширина, col, startRow, endRow, forceCompute, таблица);
  } else if (typeof ширина === 'число') {
    возврат ширина;
  } else if (ширина !== 'авто' && typeof ширина === 'строка') {
    *// возврат calc.toPx(ширина, таблица.internalProps.calcширинаContext);*
    возврат таблица._adjustColширина(col, таблица._colширинаDefineToPxширина(ширина));
  }
  возврат computeавтоColширина(ширина, col, startRow, endRow, forceCompute, таблица);
}    

```
##### Flowграфик

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/U0L9bUtB4ozAMhx3FcgcOho4n3d.gif' alt='' ширина='1000' высота='авто'>

#### авто Calculate Column ширина


в the предыдущий process, there will be logic involving автоmatic calculation из column ширина. The core logic для calculating column ширина is located в `computeавтоColширина`.    

*  computeавтоColширина（packвозрастs\vтаблица\src\scenegraph\макет\compute-col-ширина.ts）    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/BIQdb7kIboiMOhxXpewc9txEn6e.gif' alt='' ширина='1000' высота='авто'>

#### Single текст ширина Measurement


в the предыдущий process из calculating ширина, there will be situations involving measuring текст ширина. Let's analyze the process из measuring single текст ширина below.    \r

##### Overall Process


*  computeTextширина （packвозрастs\vтаблица\src\scenegraph\макет\compute-col-ширина.ts）    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/MvfnbDYdboUB0dxuVMkcNPuVnzh.gif' alt='' ширина='1000' высота='авто'>

##### Merging Cells Handling

для merged cells, a текст will be divided по multiple cells, so after calculating the ширина, it needs к be divided по the число из columns spanned по the merged cells к calculate the actual ширина occupied по the текущий cell.    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/VDirbmFJXoWnADxQz32c9hIZn9f.gif' alt='' ширина='455' высота='авто'>

##### Calculation Formulas для Different Types из Cell ширинаs

After calculating the базовый cell ширина, certain special cells need к be readjusted. Take the переключатель Кнопка as an пример:    \r

*  переключатель Кнопка calculation formula:    \r

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/EkbWbbALJoxJgnxDMkgcYVVUnah.gif' alt='' ширина='1000' высота='авто'>

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QPr3bl1I3oQrO3xx09wcC76knMc.gif' alt='' ширина='540' высота='авто'>

#### Column ширина Calculation Overall Process


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Dy8ibrEPiodNWnxVhQfcIoGtn7e.gif' alt='' ширина='1000' высота='авто'>

### Recalculate


#### Trigger Timing


There are multiple trigger points для recalculation, including:    \r

*  развернуть/свернуть Header    

* Change cell значение    

* Add rows и columns    

* Нажать к сортировка    

#### Source код & Implementation

Let's take `recalculateColширинаs`, which is triggered when a новый row is added, as an пример к explain the process из recalculating column ширинаs:    

```Typescript
// packвозрастs\vтаблица\src\scenegraph\scenegraph.ts
  */**
*   * recalculates column ширина в все автоширина columns*
*   */*
  recalculateColширинаs() {
    const таблица = this.таблица;

    if (таблица.ширинаMode === 'adaptive' || таблица.автоFillширина || таблица.internalProps.transpose) {
      computeColsширина(this.таблица, 0, this.таблица.colCount - 1, true);
    } else {
      таблица._clearColRangeширинаsMap();
      *// лево frozen*
      if (таблица.frozenColCount > 0) {
        computeColsширина(this.таблица, 0, таблица.frozenColCount - 1, true);
      }
      *// право frozen*
      if (таблица.rightFrozenColCount > 0) {
        computeColsширина(this.таблица, таблица.rightFrozenColCount, таблица.colCount - 1, true);
      }
      *// body*
      computeColsширина(таблица, this.proxy.colStart, this.proxy.colEnd, true);
    }
  }    

```
It can be seen that Vтаблица gradually updates все the columns, where the fourth параметр из все computeColsширина is true. Let's see what Vтаблица does when update is true.\r

*  Source код     

```javascript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-col-ширина.ts
функция computeColsширина() {
// ...
  if (update) {
    для (let col = 0; col < таблица.colCount; col++) {
      const newColширина = newширинаs[col] ?? таблица.getColширина(col) ?? таблица.getColширина(col);
      if (newColширина !== oldColширинаs[col]) {
        таблица._setColширина(col, newColширина, false, true);
      }
    }
    таблица.stateManвозрастr.checkFrozen();
    для (let col = 0; col < таблица.colCount; col++) {
      const newColширина = таблица.getColширина(col);
      if (newColширина !== oldColширинаs[col]) {
        таблица.scenegraph.updateColширина(col, newColширина - oldColширинаs[col], true, true);
      }
    }
    таблица.scenegraph.updateContainer(true);
  }
  //...
 }    

```
It can be seen that the internal process will judge column по column, comparing the newly calculated ширина с the старый ширина. Only when the ширина changes will it readjust the таблица ширина и update the scene tree elements. Then update the scene tree container.    \r

## Line высота Calculation


следующий, let's loхорошо в the logic для calculating line высота.    \r

### Altitude Calculation Mode


There are three modes для calculating line высота: 'standard' (standard mode), 'adaptive' (adaptive container высота mode), или 'автовысота' (автоmatic line высота mode), с 'standard' as the по умолчанию.

* 'standard': Use `defaultRowвысота` и `defaultHeaderRowвысота` as row высота;    

*  'adaptive': Scale proportionally based на the calculated высота и the ratio из the container высота к the calculated высота;    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/N9Ezb0XzaoQxD2x6WPjckoX0nGc.gif' alt='' ширина='1000' высота='авто'>

* 'автовысота': автоmatically calculate row высота based на content, calculated based на fontSize и lineвысота (текст line высота), as well as заполнение. Related setting option `автоWrapText` для автоmatic line wrapping can calculate row высота based на the content из the wrapped multi-line текст;

<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">Note that when автоFillвысота = true is configured, the enlargement according к the ratio will only occur if the row высота does не exceed the container высота.</div>
</div>
### Core Processing


#### Overall Process


*  computeRowsвысота    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/XHtabRxawoEdkxxxbayc8fc1nsg.gif' alt='' ширина='1000' высота='авто'>

The logic calculated для каждый line individually is mainly located в `computeRowвысота`, which calculates the row высота based на the configuration information.    

##### Pre-Update Check


к enter автоmatic line высота calculation, one из Следующий conditions must be met:    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/YzWdwXVPWhfcZzbMQ79c2nxXnrE.gif' alt='' ширина='820' высота='авто'>

##### body section update


Regarding the update из the body section, для certain special cases, there will be некоторые Производительность optimizations. Let's see how it is specifically operated:

1. Display в columns     

```javascript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-row-высота.ts
if (
  *// 以列展示 且符合只需要计算第一行其他行可复用行高的条条件*
  !(
    таблица.internalProps.transpose ||
    (таблица.isсводныйтаблица() && !(таблица.internalProps.макетMap as сводныйHeaderмакетMap).indicatorsAsCol)
  ) &&
  !(таблица.options as списоктаблицаConstructorOptions).пользовательскийComputeRowвысота &&
  checkFixedStyleAndNoWrap(таблица)
) {
  *// check fixed style и no wrap situation, fill все row ширина single compute*
  *// traspose таблица и row indicator сводный таблица cannot use single row высота*
  const высота = computeRowвысота(таблица.columnHeaderLevelCount, 0, таблица.colCount - 1, таблица);
  fillRowsвысота(
    высота,
    таблица.columnHeaderLevelCount,
    таблица.rowCount - 1 - таблица.bottomFrozenRowCount,
    таблица,
    update ? newвысотаs : undefined
  );
  *//底部冻结的行行高需要单独计算*
  для (let row = таблица.rowCount - таблица.bottomFrozenRowCount; row <= rowEnd; row++) {
    const высота = computeRowвысота(row, 0, таблица.colCount - 1, таблица);
    if (update) {
      newвысотаs[row] = Math.round(высота);
    } else {
      таблица._setRowвысота(row, высота);
    }
  }
}    

```
* Precondition check    

* таблица row и column transposition is не включен или it is не a сводный таблица    \r

* No пользовательский line высота calculation configured    \r

*  checkFixedStyleAndNoWrap таблица columns и cell styles can be reused    

* Specific logic    

1. Only calculate the первый line в the body, reuse that высота для other lines    \r

1. The row высота из the frozen низ row needs к be calculated separately    \r

1. Display по line    

```Typescript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-row-высота.ts
if (
  *// 以行展示*
  таблица.internalProps.transpose ||
  (таблица.isсводныйтаблица() && !(таблица.internalProps.макетMap as сводныйHeaderмакетMap).indicatorsAsCol)
) {
  для (let row = Math.max(rowStart, таблица.columnHeaderLevelCount); row <= rowEnd; row++) {
    let высота;
    if (checkFixedStyleAndNoWrapForTranspose(таблица, row)) {
      *// 以行展示 只计算到body第一列样式的情况即可*
      высота = computeRowвысота(row, 0, таблица.rowHeaderLevelCount, таблица);
    } else {
      высота = computeRowвысота(row, 0, таблица.colCount - 1, таблица);
    }
    if (update) {
      newвысотаs[row] = Math.round(высота);
    } else {
      таблица._setRowвысота(row, высота);
    }
  }
}    

```
* Precondition check    

* The таблица is a transposed таблица или a сводный таблица с indicatorsAsCol configured as false    \r

*  Specific logic    

1. Loop through the body row section    

1. Styles are reusable, и the line высота calculation range only involves the line header    

1. Non-reusable, line высота calculation range к the конец из the column    

1. Fallback, loop through the body section, call computeRowвысота line по line    \r

```javascript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-row-высота.ts
*// 以列展示 需要逐行计算情况*
для (let row = Math.max(rowStart, таблица.columnHeaderLevelCount); row <= rowEnd; row++) {
  const высота = computeRowвысота(row, 0, таблица.colCount - 1, таблица);
  if (update) {
    newвысотаs[row] = Math.round(высота);
  } else {
    таблица._setRowвысота(row, высота);
  }
}    

```
#### High Reusability Determination


<div style="заполнение:5px;фон-цвет: rgb(255, 245, 235);граница-цвет: rgb(255, 245, 235);">в cases where автоWrapText или enableLineBreak is set к true, the line высота cannot be reused, и calculations need к be done для каждый line.    
</div>
* Judgment из ordinary cells `checkFixedStyleAndNoWrap`    

```Typescript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-row-высота.ts
функция checkFixedStyleAndNoWrap(таблица: Baseтаблицаапи): логический {
  const { макетMap } = таблица.internalProps;
  const row = таблица.columnHeaderLevelCount;
  *//设置了全局自动换行的话 不能复用高度计算*
  if (
    (таблица.internalProps.автоWrapText || таблица.internalProps.enableLineBreak || таблица.isсводныйграфик()) &&
    (таблица.isавтоRowвысота() || таблица.options.высотаMode === 'adaptive')
  ) {
    возврат false;
  }
  // 每列都需要判断
  для (let col = 0; col < таблица.colCount; col++) {
    const cellDefine = макетMap.getBody(col, row);
    if (cellDefine.cellType === 'переключатель') {
      возврат false;
    }
    // 判断是否配置了自定义函数
    if (
      typeof cellDefine.style === 'функция' ||
      typeof (cellDefine as Columnданные).иконка === 'функция' ||
      (cellDefine.define as ColumnDefine)?.пользовательскийRender ||
      (cellDefine.define as ColumnDefine)?.пользовательскиймакет ||
      typeof cellDefine.define?.иконка === 'функция'
    ) {
      возврат false;
    }
    const cellStyle = таблица._getCellStyle(col, row); *//获取的style是结合了тема配置的style*
    if (
      typeof cellStyle.заполнение === 'функция' ||
      typeof cellStyle.fontSize === 'функция' ||
      typeof cellStyle.lineвысота === 'функция' ||
      cellStyle.автоWrapText === true
    ) {
      возврат false;
    }
  }
    

```
* Determine `checkFixedStyleAndNoWrapForTranspose` в the case из transposed таблицаs    

```Typescript
// packвозрастs\vтаблица\src\scenegraph\макет\compute-row-высота.ts
функция checkFixedStyleAndNoWrapForTranspose(таблица: Baseтаблицаапи, row: число): логический {
  const { макетMap } = таблица.internalProps;
  *//设置了全局自动换行的话 不能复用高度计算*
  if (
    (таблица.internalProps.автоWrapText || таблица.internalProps.enableLineBreak) &&
    (таблица.isавтоRowвысота() || таблица.options.высотаMode === 'adaptive')
  ) {
    возврат false;
  }

  const cellDefine = макетMap.getBody(таблица.rowHeaderLevelCount, row);
  // 判断是否配置了自定义函数
  if (
    typeof cellDefine.style === 'функция' ||
    typeof (cellDefine as Columnданные).иконка === 'функция' ||
    (cellDefine.define as ColumnDefine)?.пользовательскийRender ||
    (cellDefine.define as ColumnDefine)?.пользовательскиймакет ||
    typeof cellDefine.define?.иконка === 'функция'
  ) {
    возврат false;
  }
  const cellStyle = таблица._getCellStyle(таблица.rowHeaderLevelCount, row);
  if (
    typeof cellStyle.заполнение === 'функция' ||
    typeof cellStyle.fontSize === 'функция' ||
    typeof cellStyle.lineвысота === 'функция' ||
    cellStyle.автоWrapText === true
  ) {
    возврат false;
  }

  возврат true;
}    

```
#### Single Line высота Calculation


*  computeRowвысота    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/NoR5bEBXXo20xgxvTSOcNYхорошоnvd.gif' alt='' ширина='1000' высота='авто'>

#### текст высота Calculation


`автоWrapText` mainly affects the calculation из текст высота. в the case из автоmatic line wrapping, AABBBounds will be generated, и the ширина из the текст will be passed в during generation. This allows the высота из the текст к be calculated directly through AABBBounds. When автоmatic line wrapping is не включен, only lineвысота will be used as the текст высота.    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Wuj2bjjWKoGqEnx6MUzcbP7bn4c.gif' alt='' ширина='647' высота='авто'>

* computeTextвысота process    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GKycbKL65oZ2GCxKmwAcykD6nlg.gif' alt='' ширина='1000' высота='авто'>

The overall calculation formula is \u0060(Math.max(maxвысота, иконкавысота) \u002B заполнение[0] \u002B заполнение[2]) / spanRow;\u0060    \r

#### General Process


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/XcxQb5YRuoTXlWxE9bzc0fvFnbK.gif' alt='' ширина='1000' высота='авто'>

### Update Again


Taking the изменение размера из the scene tree as an пример, the row высота will only be recalculated when высотаMode is adaptive или автоFillвысота is true. There are several situations here:    \r

```javascript
// packвозрастs\vтаблица\src\scenegraph\scenegraph.ts
изменение размера() {
    // ...
    if (this.таблица.высотаMode === 'adaptive') {
      if (this.таблица.internalProps._высотаResizedRowMap.размер === 0) {
        this.recalculateRowвысотаs();
      } else {
        this.dealвысотаMode();
      }
    } else if (this.таблица.автоFillвысота) {
      this.dealвысотаMode();
    }
}    

```
1. When the column ширина is не adjusted, it is necessary к recalculate the row высота. During the calculation, the scene tree elements will be updated based на the changed rows.    \r

*  recalculateRowвысотаs ()    

```javascript
// packвозрастs\vтаблица\src\scenegraph\scenegraph.ts
  recalculateRowвысотаs() {
    const таблица = this.таблица;
    таблица.internalProps.useOneRowвысотаFillAll = false;
    if (таблица.высотаMode === 'adaptive' || таблица.автоFillвысота) {
      computeRowsвысота(this.таблица, 0, this.таблица.rowCount - 1, true, true);
    } else {
      *// верх frozen*
      if (таблица.frozenRowCount > 0) {
        computeRowsвысота(this.таблица, 0, таблица.frozenRowCount - 1, true, true);
      }
      *// низ frozen*
      if (таблица.bottomFrozenRowCount > 0) {
        computeRowsвысота(this.таблица, таблица.bottomFrozenRowCount, таблица.rowCount - 1, true, true);
      }
      computeRowsвысота(таблица, this.proxy.rowStart, this.proxy.rowEnd, true, true);
    }
  }

    

```
1. If the column ширина has been manually adjusted или автоFillвысота is включен, it will enter dealвысотаMode.    \r

Because there is no need к calculate the line высота в standard mode, the cache can be used directly during изменение размера. Therefore, only в `adaptive` или `автоFillвысота` mode will the высота из каждый line be readjusted и allocated based на the cached высота.    

*  dealвысотаMode    

```javascript
// packвозрастs\vтаблица\src\scenegraph\scenegraph.ts
  dealвысотаMode() {
    const таблица = this.таблица;
    *// 处理adaptive高度*
    if (таблица.высотаMode === 'adaptive') {
      *// 清空行高缓存*
      таблица._clearRowRangeвысотаsMap();
      *// 计算可分配高度 = 总高度 - 表头高度 - 底部冻结高度*
      const totalDrawвысота = таблица.таблицаNoFrameвысота - columnHeaderвысота - bottomHeaderвысота;
      *// 计算实际内容高度*
      для (let row = startRow; row < endRow; row++) {
        actualвысота += таблица.getRowвысота(row);
      }
      *// 计算缩放比例*
      const factor = totalDrawвысота / actualвысота;
      *// 按比例分配行高（最后一行处理余数）*
      для (let row = startRow; row < endRow; row++) {
        if (row === endRow - 1) {
          rowвысота = totalDrawвысота - 前N-1行总高度;
        } else {
          rowвысота = Math.round(原始行高 * factor);
        }
      }
    } else if (таблица.автоFillвысота) {
      *// 计算总内容高度*
      для (let row = 0; row < таблица.rowCount; row++) {
        actualвысота += таблица.getRowвысота(row);
      }
      *// 当实际高度 < 画布高度时*
      if (实际高度 < 画布高度) {
        *// 计算缩放比例（排除表头）*
        const factor = (canvasвысота - 表头高度) / (实际高度 - 表头高度);
        *// 按比例对行高进行缩放（最后一行处理剩余可分配高度）*
        для (let row = startRow; row < endRow; row++) {
          if (row === endRow - 1) {
            rowвысота = 剩余可分配高度;
          } else {
            rowвысота = Math.round(原始行高 * factor);
          }
        }
      }
    }
  }    

```
# This document is provided по Следующий personnel


taiiiyang( https://github.com/taiiiyang)     



# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)