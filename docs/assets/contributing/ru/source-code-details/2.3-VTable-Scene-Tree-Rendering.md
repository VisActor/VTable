---
заголовок: 2.3 Vтаблица Scene Tree Rendering    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
> ## Related Source код Locations
> *  packвозраст/vтаблица/src/scenegraph/group-creater/cell-helper.ts: The core file для cell processing в the Vтаблица rendering engine, providing functions для creating cells based на different column types (`createCell`), responsible для dynamic updates из cells (`updateCell` и `updateCellContent`), etc.;
> *  packвозраст/vтаблица/src/scenegraph/group-creater/column-helper.ts: Implements the merging и rendering processing из ComplexColumn based на createCell cell creation;
> *  packвозраст/vтаблица/src/scenegraph/group-creater/column.ts: Based на CreateComplexColumn, traverses от the starting column к the ending column к create column groups, thereby constructing the column structure из the entire таблица;

## таблица Creation Process


The construction process из the таблица's scene diagram is progressive, и the overall flow is roughly к первый create a single cell using the `createCell` функция, then use the `createComplexColumn` функция к create complex columns (different types из cells в the same column), и finally use the `createColGroup` функция к iterate и generate the column groups из the таблица, thereby forming the structure из the entire таблица.

Следующий is a step-по-step analysis из the creation process:

### Creation из Cells (`createCell`)

> **функция**: Create the corresponding тип из cell based на the passed cell тип `тип`. Supported types include `текст`, `imвозраст`, `video`, `график`, `progressbar`, `sparkline`, `флажок`, `переключатель`, etc.

```xml
функция createCell(
  тип: ColumnTypeOption, // 单元格类型（текст/link/imвозраст/график等）
  значение: строка,         // 单元格显示值
  define: ColumnDefine,  // 列定义配置
  таблица: Baseтаблицаапи,   // 表格实例
  col: число,           // 列索引
  row: число,           // 行索引
  colширина: число,      // 列宽
  cellширина: число,     // 单元格实际宽度（可能合并）
  cellвысота: число,    // 单元格高度
  columnгруппа: Group,    // 父容器（列组）
  y: число,             // Y轴位置
  заполнение: [число, число, число, число], // 内边距
  textAlign: CanvasTextAlign,     // 文本对齐
  textBaseline: CanvasTextBaseline, // 文本基线
  mayHaveиконка: логический,  // 是否可能包含图标
  cellтема: IтемаSpec, // 主题样式
  range: CellRange | undefined, // 合并单元格范围
  пользовательскийResult?: {     
    elementsGroup?: VGroup;
    renderDefault: логический;
  }
): Group    

```
The majority из the structure из this функция's source код follows different creation processes based на different CellTypes. It dynamically obtains various types из creation functions through `Factory.getFunction` для the created Group объект, и then configures parameters или logic processing specific к different cells.

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/MPMdbCInQo1jkXx9GC1cZ0Gmn7g.gif' alt='' ширина='528' высота='авто'>

### Column Creation (createComplexColumn)


> **функция**: Within the specified column range, create composite columns based на the merging status из cells, данные types, etc., calculate или obtain the total ширина и высота из merged cells, и optimize Производительность through Map caching.


#### Confirm insertion coordinates


The creation из complex columns begins по confirming the insertion coordinates. Based на the последний child element из `columnGroup` и the высота, determine the starting Y-coordinate для cell insertion. If cells are inserted consecutively, they are added к the existing высота по accumulating the высота из the cells, thus forming the structure из the column. This addresses the vertical positioning issue when continuously adding cells.


```javascript
let y = 0;
if (columnGroup.lastChild && (columnGroup.lastChild as Group).row === rowStart - 1) {
  y = (columnGroup.lastChild as Group).attribute.y + (columnGroup.lastChild as Group).attribute.высота;
} else if (columnGroup.colвысота) {
  y = columnGroup.colвысота;
}
    

```


#### Merge Cells dealMerge

Then начало executing the traversal loop от the starting line к the ending line к process the cell merging algorithm; handle cell merging по calculating и updating the cell's ширина и высота (calculate `mergeSize`) к achieve the merging effect. The cache here refers к using the concatenated значение из the starting row и column as the key, caching mergeResult through a Map, storing the calculated Cellширина и Cellвысота values к avoid repeated calculations.

```javascript
функция dealMerge(range: CellRange, mergeMap: MergeMap, таблица: Baseтаблицаапи, forceUpdate: логический) {
  let cellширина = 0;
  let cellвысота = 0;
  const mergeResult = mergeMap.get(`${range.начало.col},${range.начало.row};${range.конец.col},${range.конец.row}`);
  if (!mergeResult || forceUpdate) {
    для (let col = range.начало.col; col <= range.конец.col; col++) {
      cellширина += таблица.getColширина(col);
    }

    // let cellвысота = 0;
    для (let i = range.начало.row; i <= range.конец.row; i++) {
      cellвысота += таблица.getRowвысота(i);
    }

    mergeMap.set(`${range.начало.col},${range.начало.row};${range.конец.col},${range.конец.row}`, {
      cellширина,
      cellвысота
    });
  } else {
    cellширина = mergeResult.cellширина;
    cellвысота = mergeResult.cellвысота;
  }
  возврат {
    cellширина,
    cellвысота
  };
}    

```


### Creation из таблица (createColGroup)

> **функция**: Create column groups within a specified range из columns и rows к construct the column structure из the entire таблица.    

```xml
для (let i = colStart; i <= colEnd; i++) {
    const col = i;
    const colширина = таблица.getColширина(col);

    const columnGroup = новый Group({
      x: xOrigin + x,
      y: yOrigin,
      ширина: colширина,
      высота: 0,
      clip: false,
      pickable: false
    });
    columnGroup.role = 'column';
    columnGroup.col = i;
    containerGroup.addChild(columnGroup);
    const { ширина: default2ширина, высота: default2высота } = createComplexColumn(
      columnGroup,
      col,
      colширина,
      rowStart,
      rowEnd,
      таблица.scenegraph.mergeMap,
      cellLocation === 'columnHeader' && isNumber(defaultHeaderRowвысота)
        ? (defaultHeaderRowвысота as число)
        : defaultRowвысота,
      таблица,
      // cellLocation,
      rowLimit
    );
    x += default2ширина;
    высотаMax = Math.max(высотаMax, default2высота);
  }    

```
This код первый traverses от the starting column к the ending column, executing sequentially:    \r

1. Create a column group объект `columnGroup`, `x: xOrigin + x` is quite intuitive к understand, x (offset) is continuously accumulated as the column group is created в the loop, making it easy к imagine that каждый column group can be arranged sequentially в the horizontal direction; `ширина: colширина` sets the ширина из the column group к the ширина из the текущий column `colширина`, which is obtained through `таблица.getColширина(col)`; `высота: 0` initially sets the высота из the column group к 0, which will be updated later based на the высота из the elements (such as cells) actually created в the column.

1. Set the column group свойства и index, set the `role` attribute к `'column'`, и set the column group `col` attribute к the текущий column index `i`, so that it is clear which column в the таблица the column group corresponds к.    

1. по calling the `createComplexColumn` функция, create a `ComplexColumn` composite column в the specified column group и dynamically update the макет parameters. The `createComplexColumn` функция receives multiple parameters, including column group, column index, column ширина, row range, etc., и also considers the позиция из the cell, merging situation, и по умолчанию row высота, ultimately generating the corresponding column structure.



# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)