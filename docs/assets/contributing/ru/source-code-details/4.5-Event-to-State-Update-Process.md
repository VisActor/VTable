---
заголовок: 4.5 событие к State Update Process    

key words: VisActor,Vграфик,Vтаблица,VStrory,VMind,VGrammar,VRender,Visualization,график,данные,таблица,Graph,Gis,LLM
---
## Introduction


Vтаблица divides the implementation из interactive effects into three modules для processing, which are:

*  State module `stateManвозрастr`: The state module is responsible для maintaining the текущий state из various interactions в the таблица, и changes в state will lead к the re-rendering из the scene tree;    

*  The событие module is `событиеManвозрастr`: The событие module is responsible для списокening к событиеs и changing states based на different событиеs;    

*  Scene tree `scenegraph`: The scene tree is responsible для re-rendering the таблица, which is the final step в achieving interaction;    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Ikb2bbZLooBdHDxfwsRct6CLnaf.gif' alt='' ширина='1000' высота='авто'>

следующий, we will loхорошо в the process из updating событиеs к states от six common interactions.    \r

## Interaction Implementation


### Cell выбрать


#### Core State

в the state module, the core state значение that determines whether a cell is selected is `выбрать.ranges`. Vтаблица uses this поле к determine if the текущий cell is selected. Changing выбрать.ranges can change the selection state из the cell.

```Typescript
// packвозрастs\vтаблица\src\state\state.ts
выбрать: {
    ranges: (CellRange & { skipBodyMerge?: логический })[];
    //...
}    

```
Let's see how cell selection affects the state through событиеs.    

выбрать includes three types из interactions: multi-выбрать, перетаскивание multi-выбрать, и clear selection, каждый списокening к different событиеs.    \r

#### Single Choice

* pointerdown single выбрать cell    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/QKzLb3NQwo2gESxn29ec7nI8nCf.gif' alt='' ширина='740' высота='авто'>

After handling the cell selection событие, update interactionState     \r

```javascript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
stateManвозрастr.updateInteractionState(InteractionState.grabing);    

```
As для whether к update the logic из the текущий cell selection status, it is located в the state module `stateManвозрастr.updateSelectPos`.    

#### перетаскивание и выбрать


* pointermove multi-выбрать cells    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/N3S5b9ojioIPbExzQfGcnz5znWg.gif' alt='' ширина='515' высота='авто'>



#### Clear Selection

* The событие module receives the pointertap событие, Нажатьing на a blank area отменаs the selection и ends the выбрать interaction.    \r

```xml
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
   таблица.scenegraph.stвозраст.addсобытиесписокener('pointertap', (e: FederatedPointerсобытие) => {
    // ...
      if (таблица.options.выбрать?.blankAreaНажатьDeselect ?? true) {
        событиеManвозрастr.dealтаблицаSelect();
      }    
      // ...
  }    

```
#### Status Update


в the process из the выбрать cell в the state module, the core difference between single-выбрать cells и box-выбрать cells lies в the difference из stateManger.interactionState:

*  stateManвозрастr.interactionState === 'grabing' indicates the process из selecting cells is currently ongoing    

*  stateManвозрастr.interactionState === 'по умолчанию' indicates a single selection cell    

---
The update process regarding the selection state в state manвозрастment is as follows:    \r

*  updateSelectPos    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/C4Asbхорошоs2ou17Tx7nyTcGDDMn6b.gif' alt='' ширина='1000' высота='авто'>

### Scrollbar Scrolling


The scrolling effect mainly списокens к the `wheel` событие. по using the `wheel` событие, it changes the текущий scrollbar state, updates scrollTop и scrollLeft, и adjusts the x, y coordinates из the таблица к achieve the scrolling effect.

#### Core State


```javascript
// packвозрастs\vтаблица\src\state\state.ts
  прокрутка: {
    horizontalBarPos: число;
    verticalBarPos: число;
  };
    

```
#### Update Process


<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/WVxvbjLqMoyD0zxiOb6cvbX5noc.gif' alt='' ширина='1000' высота='авто'>

### навести cell


#### Core State


```javascript
// packвозрастs\vтаблица\src\state\state.ts
  навести: {
    cellPos: CellPosition; *// 记录当前hover的位置*
  };    

```
Vтаблица internally uses навести.cellPos к determine whether the текущий cell is в a навести state, thereby implementing the навести cell функциональность.    \r

#### Processing Flow

The cell навести effect is achieved по списокening к the `pointermove` событие.    

1. первый, the событие module handles the pointermove событие    

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
  таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointermove', (e: FederatedPointerсобытие) => {
    // ...
    const событиеArgsSet = getCellсобытиеArgsSet(e);
    событиеManвозрастr.dealтаблицаHover(событиеArgsSet);
    // ...
  })    

```
1. The событие module `событиеManвозрастr.dealтаблицаHover` handles the навести effect, determining whether к clear или update the навести state through событиеArgs.    

```Typescript
// packвозрастs\vтаблица\src\событие\событие.ts
  dealтаблицаHover(событиеArgsSet?: Sceneсобытие) {
    if (!событиеArgsSet) {
      this.таблица.stateManвозрастr.updateHoverPos(-1, -1);
      возврат;
    }
    const { событиеArgs } = событиеArgsSet;

    if (событиеArgs) {
      this.таблица.stateManвозрастr.updateHoverPos(событиеArgs.col, событиеArgs.row);
    } else {
      this.таблица.stateManвозрастr.updateHoverPos(-1, -1);
    }
  }
    

```
1. State module updates навести позиция `stateManвозрастr.updateHoverPos`    

*  Overall flowграфик    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/XWvtbdteGoR9pkxuS2CcR4RFnPe.gif' alt='' ширина='1000' высота='авто'>

### Row высота и Column ширина Adjustment


#### Core State


```javascript
// packвозрастs\vтаблица\src\state\state.ts
columnResize: {
  col: число;
  */** x坐标是相对таблица内坐标 */*
  x: число;
  resizing: логический;
};
rowResize: {
  row: число;
  */** y坐标是相对таблица内坐标 */*
  y: число;
  resizing: логический;
};    

```
The state records the index и coordinates из the текущий dragged row и column. в the subsequent actual dragging, only the corresponding row или column из `columnResize.col` или `rowResize.row` will be adjusted.    

#### Adjusting Process


* Receive pointerdown событие, checked по the событие module к see if it enters the перетаскивание к adjust column ширина. If confirmed к enter row высота и column ширина adjustment, update `state.interactionState` к `grabing`; 

```Typescript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
  таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointerdown', (e: FederatedPointerсобытие) => {
  // ...
  *// 处理列宽调整*
  if (
    !событиеManвозрастr.checkCellFillhandle(событиеArgsSet) &&
    (событиеManвозрастr.checkColumnResize(событиеArgsSet, true) || событиеManвозрастr.checkRowResize(событиеArgsSet, true))
  ) {
    таблица.scenegraph.updateграфикState(null);
    stateManвозрастr.updateInteractionState(InteractionState.grabing);
    возврат;
  }
  // ...
 }    

```
* первый, based на the Нажать coordinates provided по `pointerdown`, calculate whether the перетаскивание hotspot is hit. If it is hit, возврат the corresponding row и column index.    

* перетаскивание column ширина check    

```javascript
// packвозрастs\vтаблица\src\событие\событие.ts
  checkColumnResize(событиеArgsSet: Sceneсобытие, update?: логический): логический {
    const { событиеArgs } = событиеArgsSet;
    // ...
    *// 如果是鼠标处理表格外部如最后一列的后面 也期望可以拖拽列宽*
    // 获取当前点击的单元格行列号
    const resizeCol = this.таблица.scenegraph.getResizeColAt(
      событиеArgsSet.abstractPos.x,
      событиеArgsSet.abstractPos.y,
      событиеArgs?.targetCell
    );
    if (this.таблица._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0) {
      if (update) {
        this.таблица.stateManвозрастr.startResizeCol(
          resizeCol.col,
          событиеArgsSet.abstractPos.x,
          событиеArgsSet.abstractPos.y,
          resizeCol.rightFrozen
        );
      }
      возврат true;
    }
    // ...
  }    

```
* перетаскивание row высота check    

```javascript
// packвозрастs\vтаблица\src\событие\событие.ts
  checkRowResize(событиеArgsSet: Sceneсобытие, update?: логический): логический {
  // ...
    const { событиеArgs } = событиеArgsSet;
    if (событиеArgs) {
      const resizeRow = this.таблица.scenegraph.getResizeRowAt(
        событиеArgsSet.abstractPos.x,
        событиеArgsSet.abstractPos.y,
        событиеArgs.targetCell
      );

      if (this.таблица._canResizeRow(resizeRow.col, resizeRow.row) && resizeRow.row >= 0) {
        if (update) {
          this.таблица.stateManвозрастr.startResizeRow(
            resizeRow.row,
            событиеArgsSet.abstractPos.x,
            событиеArgsSet.abstractPos.y,
            resizeRow.bottomFrozen
          );
        }
        возврат true;
      }
    }

  }
    

```
* Based на the row и column index, initialize the state из `columnResize` и `rowResize` through the state module, triggering the следующий frame rendering;    \r

```Typescript
// packвозрастs\vтаблица\src\state\state.ts
  startResizeCol(col: число, x: число, y: число, isRightFrozen?: логический) {
    this.columnResize.resizing = true;
    this.columnResize.col = col;
    this.columnResize.x = x;
    this.columnResize.isRightFrozen = isRightFrozen;

    this.таблица.scenegraph.компонент.showResizeCol(col, y, isRightFrozen);
    this.таблица.scenegraph.updateNextFrame();
  }    

```
* Handle the `pointermove` событие, и determine whether it is dragging a row или a column through the state module;    

* If interactionState === 'grabing', it means currently в the interaction из dragging row высота или column ширина;    

*  Determine whether the текущий action is dragging row высота или column ширина по `columnResize.resizing` и `rowResize.resizing`;    

*  Use the событие module as an intermediary к handle перетаскивание событиеs `событиеManвозрастr.dealColumnResize(x, y)`;    

*  Trigger `RESIZE_COLUMN` и `RESIZE_ROW` событиеs;    \r

```javascript
  const globalPointermoveCallback = (e: Mouseсобытие) => {
  // ... 
    const { x, y } = таблица._getMouseAbstractPoint(e, false);
    if (stateManвозрастr.interactionState === InteractionState.grabing) {
      if (stateManвозрастr.isResizeCol()) {
        событиеManвозрастr.dealColumnResize(x, y);
        if ((таблица as любой).hasсписокeners(таблица_событие_TYPE.RESIZE_COLUMN)) {
          таблица.fireсписокeners(таблица_событие_TYPE.RESIZE_COLUMN, {
            col: таблица.stateManвозрастr.columnResize.col,
            colширина: таблица.getColширина(таблица.stateManвозрастr.columnResize.col)
          });
        }
      } else if (stateManвозрастr.isResizeRow()) {
        событиеManвозрастr.dealRowResize(x, y);
        if ((таблица as любой).hasсписокeners(таблица_событие_TYPE.RESIZE_ROW)) {
          таблица.fireсписокeners(таблица_событие_TYPE.RESIZE_ROW, {
            row: таблица.stateManвозрастr.rowResize.row,
            rowвысота: таблица.getRowвысота(таблица.stateManвозрастr.rowResize.row)
          });
        }
      }
    }
  // ...
  }
  document.body.addсобытиесписокener('pointermove', globalPointermoveCallback);    

```
*  Handle the `pointermove` событие through the state module, и update the column ширина/row высота в the corresponding index из `columnResize.col` и `rowResize.row` using the текущий pointer coordinates.    

```Typescript
// packвозрастs\vтаблица\src\событие\событие.ts
  dealColumnResize(xInтаблица: число, yInтаблица: число) {
    this.таблица.stateManвозрастr.updateResizeCol(xInтаблица, yInтаблица);
  }

  dealRowResize(xInтаблица: число, yInтаблица: число) {
    this.таблица.stateManвозрастr.updateResizeRow(xInтаблица, yInтаблица);
  }    

```
* Handle the `pointerup` событие, restoring `state.interactionState` к `по умолчанию`;    

```javascript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
  таблица.scenegraph.stвозраст.addсобытиесписокener('pointerup', (e: FederatedPointerсобытие) => {
    *// 处理列宽调整  这里和таблицаGroup.addсобытиесписокener('pointerup' 逻辑一样*
    if (stateManвозрастr.interactionState === 'grabing') {
      stateManвозрастr.updateInteractionState(InteractionState.по умолчанию);
      if (stateManвозрастr.isResizeCol()) {
        endResizeCol(таблица);
      } else if (stateManвозрастr.isResizeRow()) {
        endResizeRow(таблица);
      }
    }
  });    

```
* Delegate к the state module к reset `stateManвозрастr.columnResize` и `stateManвозрастr.rowResize`, then trigger the `RESIZE_COLUMN_END` или `RESIZE_ROW_END` событие    

```javascript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
export функция endResizeCol(таблица: Baseтаблицаапи) {
  таблица.stateManвозрастr.endResizeCol();
  const columns = [];
  *// 返回所有列宽信息*
  для (let col = 0; col < таблица.colCount; col++) {
    columns.push(таблица.getColширина(col));
  }
  таблица.fireсписокeners(таблица_событие_TYPE.RESIZE_COLUMN_END, {
    col: таблица.stateManвозрастr.columnResize.col,
    colширинаs: columns
  });
}

export функция endResizeRow(таблица: Baseтаблицаапи) {
  таблица.stateManвозрастr.endResizeRow();

  таблица.fireсписокeners(таблица_событие_TYPE.RESIZE_ROW_END, {
    row: таблица.stateManвозрастr.rowResize.row,
    rowвысота: таблица.getRowвысота(таблица.stateManвозрастr.rowResize.row)
  });    

```
* Reset `columnResize.resizing` и `rowResize.resizing` к false, скрыть the перетаскивание baseline, и proceed к the следующий frame rendering.    

```javascript
// packвозрастs\vтаблица\src\state\state.ts
  endResizeCol() {
    setTimeout(() => {
      this.columnResize.resizing = false;
    }, 0);
    // ...
    this.таблица.scenegraph.компонент.hideResizeCol();
    this.таблица.scenegraph.updateNextFrame();
  }
  endResizeRow() {
    setTimeout(() => {
      this.rowResize.resizing = false;
    }, 0);
    // ...
    this.таблица.scenegraph.компонент.hideResizeRow();
    this.таблица.scenegraph.updateNextFrame();
  }    

```
*  Flowграфик    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/GhLAbSX5Mo9mZsxw2Sxcwxgrnkb.gif' alt='' ширина='1000' высота='авто'>

### перетаскивание к Change Rows и Columns


#### Core State


```javascript
// packвозрастs\vтаблица\src\state\state.ts
  columnMove: {
    colSource: число;
    colTarget: число;
    rowSource: число;
    rowTarget: число;
    x: число;
    y: число;
    moving: логический;
  };    

```
columnRemove stores the original index и target index из the dragged row или column, as well as a flag indicating whether it is в motion. по changing `colTarget` и `rowTarget`, Вы можете achieve the функция из replacing the selected row/column к the target позиция.    

#### Processing Flow


Dragging к change rows и columns also relies на three событиеs к complete: `pointerdown`, `pointermove`, `pointerup`

*  Flowграфик    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/H1Gebs14DoUQWOxF53icOGhjn9d.gif' alt='' ширина='1000' высота='авто'>

### Fixed Column


Vтаблица provides a built-в frozen column operation, which can be включен по configuring `allowFrozenColCount`.    

<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourceкод/img/Xz8kbT8hDoW669xVm95cHoLbnZd.gif' alt='' ширина='568' высота='авто'>

#### Core State


Vтаблица maintains the текущий actual число из frozen columns through the `таблицаInstance.internalProps.frozenColCount` state, и internally adjusts the число из frozen columns на the лево side based на this поле, applying special styles.    

#### Processing Flow

The operation из freezing columns is mainly implemented по `pointertap` и the пользовательский событие `иконка_Нажать`.    

* первый handle the `pointertap` событие;    

```javascript
// packвозрастs\vтаблица\src\событие\списокener\таблица-group.ts
  таблица.scenegraph.таблицаGroup.addсобытиесписокener('pointertap', (e: FederatedPointerсобытие) => {
  // ...
    if (
      !событиеManвозрастr.touchMove &&
      e.Кнопка === 0 &&
      событиеArgsSet.событиеArgs &&
      (таблица as любой).hasсписокeners(таблица_событие_TYPE.Нажать_CELL)
    ) {
    // ...
    событиеManвозрастr.dealиконкаНажать(e, событиеArgsSet);

  });    

```
* в the событие module, it is determined по событиеArgsSet whether the иконка element is Нажатьed. If the Нажатьed element is an иконка, the пользовательский событие `иконка_Нажать` is triggered.    

```javascript
// packвозрастs\vтаблица\src\событие\событие.ts
 dealиконкаНажать(e: FederatedPointerсобытие, событиеArgsSet: Sceneсобытие): логический {
    const { событиеArgs } = событиеArgsSet;

    const { target, событие, col, row } = событиеArgs || {
      target: e.target,
      событие: e,
      col: -1,
      row: -1
    };
    const иконка = target as unknown as иконка;

    if (иконка.role && иконка.role.startsWith('иконка-')) {
      this.таблица.fireсписокeners(таблица_событие_TYPE.иконка_Нажать, {
        имя: иконка.имя,
        *// 默认位置：иконка中部正下方*
        x: (иконка.globalAABBBounds.x1 + иконка.globalAABBBounds.x2) / 2,
        y: иконка.globalAABBBounds.y2,
        col,
        row,
        funcType: иконка.attribute.funcType,
        иконка,
        событие
      });

  }    

```
* The `иконка_Нажать` событие is регистрацияed as early as the событие module initialization, и the `иконка_Нажать` событие will determine whether the текущий Нажатьed иконка тип is frozen;    

```javascript
// packвозрастs\vтаблица\src\событие\событие.ts
    *// 图标点击*
    this.таблица.на(таблица_событие_TYPE.иконка_Нажать, иконкаInfo => {
      const { col, row, x, y, funcType, иконка, событие } = иконкаInfo;
      // ...
      if (funcType === иконкаFuncTypeEnum.frozen) {
        stateManвозрастr.triggerFreeze(col, row, иконка);
      } 
      // ...
    });
    

```
* The status module handles the Нажать `fronzen` событие. Based на the index из the currently Нажатьed column, it updates `this.internalProps.frozenColCount`. If the currently Нажатьed column is the same as the `frozenColCount` maintained в the state, it resets `frozenColCount` к 0; if different, it updates `frozenColCount` к col.;

```javascript
// packвозрастs\vтаблица\src\state\frozen\index.ts
export функция dealFreeze(col: число, row: число, таблица: Baseтаблицаапи) {
  if (таблица.frozenColCount > 0) {
    if (col !== таблица.frozenColCount - 1) {
      таблица.setFrozenColCount(col + 1);
    } else {
      таблица.setFrozenColCount(0);
    }
  } else {
    таблица.setFrozenColCount(col + 1);
  }
}
    

```
* Trigger the `FREEZE_Нажать` событие    

```javascript
  triggerFreeze(col: число, row: число, иконкаMark: иконка) {
  // ...
    if ((this.таблица as любой).hasсписокeners(сводный_таблица_событие_TYPE.FREEZE_Нажать)) {
      const полеs: Columnданные[] = (this.таблица as списоктаблица).internalProps.макетMap.columnObjects.slice(0, col + 1);
      this.таблица.fireсписокeners(сводный_таблица_событие_TYPE.FREEZE_Нажать, {
        col: col,
        row: row,
        полеs: полеs.reduce((pre: любой, cur: любой) => pre.concat(cur.поле), []),
        colCount: this.таблица.frozenColCount
      });
    }
    // ...
   }    

```
## Conclusion


This article starts от six common interaction effects и explains в detail the process из updating от событиеs к states.

Vтаблица separates interactive effects into событие modules и state modules, making the process из handling interactive событиеs clearer.

# This document is provided по Следующий personnel


taiiiyang( https://github.com/taiiiyang)    

# This document was revised и organized по Следующий personnel 
 [玄魂](https://github.com/xuanhun)